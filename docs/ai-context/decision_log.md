# 의사결정 로그 (Decision Log)

## 아키텍처 (Architecture)
... (기존 내용 유지) ...

## 파일 시스템 브라우징
### 시스템 디렉토리 필터링 (2026-02-03)
... (기존 내용 유지) ...

### GUI 탐색기 설계 (2026-02-03)
- **결정**: Google Drive와 유사한 사용자 경험을 위해 리스트 대신 `Table`과 `Breadcrumb`을 조합한 탐색기 구조 채택.
- **이유**: 단순 리스트보다 많은 정보(크기, 수정일)를 한눈에 보여줄 수 있으며, 복잡한 경로 탐색 시 Breadcrumb이 필수적임.
- **기술 선택**: Ant Design `Table`의 `onRow` 속성을 이용한 더블 클릭 진입 처리, `filepath.Clean` 기반의 경로 상태 관리.

## 데이터 모델
### FileInfo 확장 (2026-02-03)
- **결정**: `FileInfo` 구조체에 `Size` (int64) 및 `ModTime` (time.Time) 추가.
- **이유**: 파일 탐색기의 기본 기능인 '상세 보기' 및 '정렬' 기능을 지원하기 위함.

## Space와 파일 브라우저 연동
### Space 선택 시 자동 경로 이동 (2026-02-04)
- **결정**: Space 메뉴 클릭 시 해당 Space의 `space_path`를 파일 브라우저에 전달하여 자동 이동.
- **이유**: 사용자가 Space를 클릭했을 때 루트 디렉토리가 아닌 Space의 실제 경로에서 탐색을 시작해야 직관적임.
- **구현 방식**:
  - `MainLayout`에서 `selectedSpace`, `selectedPath` 상태 관리 및 `Outlet` context로 전달.
  - `FileExplorer`가 `useOutletContext`로 경로 정보 및 변경 핸들러를 받음.
  - `FolderTree`에 `rootPath` prop 추가: Space 경로가 있으면 해당 경로부터 트리 시작, 없으면 기존처럼 base directories 로드.
- **수정 파일**: `MainLayout/index.tsx`, `MainSider.tsx`, `FileExplorer.tsx`, `FolderTree.tsx`

### UI 레이아웃 통합 (2026-02-04)
- **결정**: `FolderTree`를 `FileExplorer`에서 분리하여 좌측 사이드바(`MainSider`)로 이동.
- **이유**: Space 목록과 FolderTree를 분리할 필요 없이, 좌측 사이드바에서 Space 선택 → FolderTree 탐색이 자연스러운 흐름.
- **레이아웃 변경**:
  - **이전**: 좌측 사이드바(Space 목록) / 중간(FolderTree) / 우측(FolderContent)
  - **이후**: 좌측 사이드바(Space 목록 + FolderTree) / 우측(FolderContent 전체)
- **장점**: 화면 공간 효율적 사용, 직관적인 계층 구조 표시.

### FolderTree 기본 동작 변경 (2026-02-04)
- **결정**: Space가 선택되지 않은 상태에서는 FolderTree가 아무것도 표시하지 않음.
- **이유**: 시스템 루트 디렉토리를 기본으로 표시할 필요 없음. Space 중심의 워크플로우를 강조.
- **구현**: `rootPath`가 없으면 빈 상태 메시지("Space를 선택하세요") 표시, base directories 자동 로드 제거.

### Space와 FolderTree 완전 통합 (2026-02-04)
- **결정**: Space 메뉴와 FolderTree를 하나의 통합된 트리 구조로 병합.
- **이유**:
  - Space 목록과 폴더 탐색을 별도로 보여줄 필요 없음.
  - 단일 계층 구조로 UX 단순화 및 일관성 향상.
  - 모든 Space를 한눈에 보면서 각 Space 내부를 탐색 가능.
- **구현**:
  - `FolderTree`에 `spaces` prop 추가.
  - Spaces를 `space-{id}` 형태의 key를 가진 루트 노드로 생성.
  - Space 노드 확장 시 `space_path`로부터 하위 디렉토리 lazy loading.
  - `MainSider`에서 Menu 제거, Spaces 헤더 + FolderTree만 표시.
  - Space 선택 시 `space_path` 반환하여 FolderContent 업데이트.
- **특수 케이스**: `showBaseDirectories` 플래그로 모달에서는 시스템 디렉토리 탐색 가능.

## 개발 프로세스
### 전역 검색(#122) 헤더 배치 시안 채택 (2026-02-22)
- **문제**:
  - 검색 UI를 콘텐츠 영역에 둘지 헤더에 둘지 결정되지 않아 접근성/레이아웃 일관성 논의가 필요했다.
- **결정**:
  - 1차 시안은 헤더 배치로 진행한다.
    - 데스크톱: 헤더 중앙 입력 상시 노출
    - 모바일: 검색 아이콘 탭 시 헤더 입력 토글
- **이유**:
  - 탐색 화면 어디서든 빠르게 접근 가능하고, 향후 검색 결과 오버레이 확장 시 구조적 이점이 크기 때문.
- **후속**:
  - 현재는 UI 시안만 반영했고, 검색 API/결과 리스트/클릭 이동은 `#122` 구현 단계에서 연결한다.

### 전역 검색(#122) 2차 구현 방향 확정 (2026-02-22)
- **문제**:
  - 검색 범위를 현재 선택 Space로 제한할지, 연결된 전체 Space로 확장할지 결정이 필요했다.
  - 검색 실행 후 결과를 어디서 보여줄지(헤더 오버레이 vs 전용 화면) UX 동선이 필요했다.
- **결정**:
  - 검색 범위는 `연결된 전체 Space`를 기본값으로 한다.
  - 헤더 입력은 즉시결과(상위 N개)를 드롭다운으로 보여주고, `Enter` 입력 시 전용 결과 화면(`/search`)으로 이동한다.
  - 전용 결과 화면은 기존 파일 탐색기 톤(리스트 중심 UI, 동일 아이콘/상태 스타일)을 재사용한다.
  - 백엔드는 `GET /api/search/files`를 추가하고, Space별 `read` 권한 필터 후 재귀 검색한다.
    - 숨김 파일/폴더(`.` prefix)는 검색 대상에서 제외
    - `limit` 파라미터 지원(기본 80, 최대 200)
- **이유**:
  - 사용자 입장에서 "어느 Space에 있는지 몰라도 한 번에 찾는" 탐색 경험이 우선이며,
    헤더 즉시결과와 전용 화면을 분리하면 빠른 점프와 상세 탐색을 동시에 만족할 수 있기 때문.
  - 권한 필터를 핸들러에서 강제해 cross-space 검색에서도 기존 보안 경계를 유지할 수 있기 때문.

### 검색 전용 화면의 탐색기 컴포넌트 재사용 정책 확정 (2026-02-22)
- **문제**:
  - 검색 전용 화면이 별도 Table 구현을 유지하면, 파일 탐색기 UI 변경 시 검색 화면이 쉽게 드리프트될 수 있음.
  - 반대로 `FolderContent` 전체를 그대로 재사용하면 browse 전용 상태/액션 의존성이 커서 회귀 리스크가 큼.
- **결정**:
  - `FolderContent` 전체 재사용 대신, 탐색기의 표시 컴포넌트 단위(`FolderContentTable`)를 검색 화면에서 직접 재사용한다.
  - `FolderContentTable`에 읽기 전용 재사용을 위한 최소 옵션을 추가한다.
    - `showActions` (행 우측 액션 버튼 on/off)
    - `renderMeta` (검색 전용 보조정보 렌더)
    - `emptyText` (문맥별 empty 문구)
    - `rowKeyResolver` (cross-space 중복 경로 키 충돌 방지)
- **이유**:
  - UI 일관성(행 스타일/아이콘/테이블 톤)을 확보하면서도, browse 전용 복잡 로직(선택/드래그/파일작업)의 결합을 피할 수 있기 때문.
  - 점진적 리팩터링 전략에서 가장 비용 대비 효과가 높은 중간 단계이기 때문.

### `/search` 라우트의 `FileExplorer` 직접 재사용으로 통합 (2026-02-22)
- **문제**:
  - 검색 결과를 별도 페이지 컴포넌트로 유지하면, 라우트별 UI 드리프트가 다시 발생할 가능성이 높음.
  - 트리 클릭 시 browse 화면 복귀 동선도 라우트별 분기에서 흔들릴 수 있음.
- **결정**:
  - `/search` 라우트도 `FileExplorer` 자체를 렌더하고, 내부에서 현재 경로 기준으로 데이터 소스만 전환한다.
  - 검색 데이터 소스는 `useSearchExplorerSource`, 검색 뷰는 `SearchExplorerContent`로 분리해 주입한다.
- **이유**:
  - 컨테이너/레이아웃을 단일화하면 탐색기 경험의 일관성이 유지되고, 기능 변경 시 수정 지점을 최소화할 수 있기 때문.
  - 이후 `BrowseSource`/`SearchSource` 확장을 통해 완전한 source adapter 구조로 발전시키기 쉽기 때문.

### 검색 결과 렌더링을 `FolderContent` 내부 소스 전환으로 최종 통합 (2026-02-22)
- **문제**:
  - `/search`가 `FileExplorer`를 재사용하더라도 내부가 `SearchExplorerContent` 전용 분기면 사용자가 여전히 별도 화면으로 인지한다.
  - 검색 화면과 일반 탐색 화면의 상단/하단 구조가 분리되면 향후 UI 변경 시 동기화 비용이 다시 커진다.
- **결정**:
  - `FileExplorer`는 항상 `FolderContent`만 렌더링한다.
  - `FolderContent` 내부에서 라우트 기준으로 데이터 소스만 전환한다.
    - browse 모드: 기존 `browseStore.content`
    - search 모드: `useSearchExplorerSource` 결과를 `FileNode`로 어댑트한 소스
  - 상태 렌더링(loading/error/empty), 상단 툴바, 하단 경로바는 공통 골격을 그대로 사용한다.
  - 검색 모드에서는 쓰기 액션/컨텍스트 메뉴를 비활성화하고 결과 오픈 동선만 제공한다.
- **이유**:
  - 사용자 체감 기준으로 동일한 파일 익스플로러를 유지하려면 "컴포넌트 재사용"이 아니라 "내부 골격 재사용"이 필요하기 때문.
  - 추후 정렬/레이아웃/상태 UI를 수정할 때 browse/search 동시 반영이 보장되어 유지보수 리스크가 줄어든다.

### 검색 결과 복귀 액션을 `<` 버튼에 통합 (2026-02-22)
- **문제**:
  - 검색 결과에서 파일을 열어 browse(`/`)로 이동한 뒤 복귀할 때, `<`/`>`와 별도의 `검색 결과로` 버튼이 공존해 내비게이션 의미가 분산됐다.
- **결정**:
  - `검색 결과로` 전용 버튼은 제거한다.
  - `<` 버튼에 fallback 동작을 추가한다.
    - 폴더 히스토리가 있으면 기존처럼 폴더 뒤로 이동
    - 폴더 히스토리가 없고 `fromSearchQuery`가 있으면 `/search?q=...`로 복귀
- **이유**:
  - 동일한 "뒤로" 개념을 하나의 버튼으로 통합하면 조작 모델이 단순해지고, 탐색기 툴바의 버튼 수를 줄여 인지 부하를 낮출 수 있기 때문.
  - 기존 폴더 히스토리 UX를 깨지 않으면서 검색 복귀 동선을 최소 변경으로 흡수할 수 있기 때문.

### 검색 반복 시 성능 저하 대응: 요청 취소 + 서버 조기중단 + 경로 계산 지연 (2026-02-22)
- **문제**:
  - 검색을 연속 수행할 때 이전 요청이 화면에서는 무시되더라도 네트워크/서버 작업이 계속 진행되어 누적 지연이 발생할 수 있었다.
  - 백엔드 검색 루프가 요청 취소를 반영하지 않아 `WalkDir`가 끝까지 실행되는 경우가 있었다.
  - 짧은 쿼리에서 path 매칭을 사용하지 않는데도 매 엔트리마다 `filepath.Rel`을 수행해 불필요한 비용이 발생했다.
- **결정**:
  - 프론트 검색 경로(헤더 즉시검색 + `/search` 결과 로드)에 `AbortController`를 도입해 이전 in-flight 요청을 즉시 취소한다.
  - 백엔드 검색 핸들러의 space loop/`WalkDir` 콜백에서 `context` 취소를 확인해 조기 중단한다.
  - `filepath.Rel` 계산은 실제 path 매칭 또는 결과 직렬화가 필요한 시점에만 수행하도록 지연한다.
- **이유**:
  - 같은 사용자 입력 흐름에서 중복되는 검색 작업을 즉시 제거하면 체감 지연과 서버 부하를 동시에 줄일 수 있기 때문이다.
  - 취소 반영과 계산 지연은 API 계약을 바꾸지 않고도 적용 가능한 저위험 성능 개선이다.

### 검색 모드 트리 상태를 루트 기준으로 리셋해 누적 확장 비용 차단 (2026-02-22)
- **문제**:
  - 검색 결과에서 deep 경로를 열고 다시 `/search`로 돌아오는 흐름을 반복하면, 트리의 `expandedKeys/loadedKeys/children` 상태가 누적되어 렌더/상태 갱신 비용이 커질 수 있었다.
  - deep key 자동 확장 시점에 상위 노드가 아직 트리에 주입되지 않았는데도 로딩 완료로 마킹되면, 이후 정상 로딩이 누락될 위험이 있었다.
- **결정**:
  - `MainSider`가 라우트 기준 `isSearchMode`를 `FolderTree`에 전달한다.
  - `FolderTree`는 검색 모드 진입 시
    - `expandedKeys`를 비우고,
    - `loadedKeys`를 비우고,
    - 루트 노드 하위 `children`을 제거해 트리 내부 상태를 루트 기준으로 정리한다.
  - `loadChildrenForKey`는 `treeDataRef` 기반 노드 존재 확인 후에만 로딩을 수행해, 성급한 deep key 로딩 완료 마킹을 방지한다.
- **이유**:
  - 검색/복귀 반복 시 누적 상태를 주기적으로 비워 트리 관련 렌더 비용을 안정화할 수 있기 때문이다.
  - deep 경로 자동 확장 정확도를 유지하면서도 `useCallback` 재생성 비용을 늘리지 않는 안전한 방식이기 때문이다.

### 검색 결과 클릭 전환 시 트리 자동 동기화 경량화 (2026-02-22)
- **문제**:
  - `/search` 결과 클릭 후 `/`로 이동할 때, 트리 자동 확장이 deep 경로의 모든 형제 디렉터리를 함께 렌더링해 메인 스레드 long task가 크게 발생했다.
  - 특히 `node_modules`처럼 자식 수가 많은 경로에서 트리 노드 수가 급증해 전환 체감 지연이 발생했다.
- **결정**:
  - 자동 확장 시 선택 노드 자체는 제외하고 상위 경로까지만 확장한다.
  - 검색->브라우즈 자동 동기화 구간에서는 자식 수가 큰 디렉터리(`> 40`)에 한해 선택 경로 하위만 우선 로드한다.
  - 사용자가 해당 노드를 직접 확장하면 partial 상태를 해제하고 전체 자식 목록을 다시 로드(hydrate)한다.
  - `/search` 결과 로드 limit은 `120`에서 `80`으로 조정한다.
- **이유**:
  - 사용자 기대(트리 경로 동기화)는 유지하면서 초기 전환 비용의 대부분을 차지하는 대량 형제 렌더를 줄일 수 있기 때문이다.
  - 고정 limit 하향은 Enter 전환 시 초기 테이블 렌더 비용을 즉시 낮출 수 있는 저위험 조치다.

### 전환 성능 수정셋 스코프 정리 (2026-02-22)
- **문제**:
  - 전환 지연 대응 변경과 무관한 수정이 함께 포함되면 리뷰/롤백 범위가 커질 수 있다.
- **결정**:
  - `FolderContent`에서 검색 모드 강제 table 정책과 충돌하던 dead code를 제거한다.
  - 백엔드 검색 최적화 변경(`account/service.go`, `search_handler.go`, `search_handler_test.go`)은 이번 정리 변경셋에서는 제외하고 별도 범위로 유지한다.
- **이유**:
  - 전환 성능 이슈의 핵심 원인을 프론트 렌더 경로로 좁혀 검증/리뷰 가능성을 높이기 위해서다.

### 검색 모드 뷰 토글 재허용 (2026-02-22)
- **문제**:
  - 검색 모드에서 뷰를 table로 강제하면 툴바에 grid 버튼이 노출돼도 실제 전환이 되지 않아 UX 불일치가 발생한다.
- **결정**:
  - `FolderContent`의 검색 모드 강제 table 고정을 제거하고, `/search`에서도 기존 뷰 토글 상태(`table/grid`)를 그대로 사용한다.
  - 검색 모드의 읽기 전용 제약(쓰기 액션/컨텍스트 메뉴/드래그 비활성)은 유지한다.
- **이유**:
  - 동일한 탐색기 툴바 조작 모델을 browse/search 모두에서 일관되게 유지하기 위해서다.
  - 전환 성능 대응과 뷰 토글 허용은 독립 축이므로, 사용자 조작성을 복원해도 안정화 변경의 핵심 효과를 유지할 수 있기 때문이다.

### 검색 화면에서 Space 트리 선택 하이라이트 해제 정책 확정 (2026-02-22)
- **문제**:
  - `/search`에서 파일 목록은 검색 결과 기준으로 바뀌는데, 좌측 트리가 기존 Space/경로를 선택 상태로 유지하면 현재 컨텍스트와 시각 신호가 충돌한다.
- **결정**:
  - 검색 라우트(`/search`)에서는 트리 `selectedKeys`를 빈 배열로 강제해 하이라이트를 숨긴다.
  - browse 라우트에서는 기존 store 기반 선택키를 그대로 사용한다.
  - 트리 노드 클릭 시에는 기존 동선대로 browse(`/`) 복귀 + 해당 Space/경로 선택 표시를 재적용한다.
- **이유**:
  - 전체 검색 결과 문맥에서는 "특정 트리 노드 선택"보다 "검색 결과 컨텍스트"가 우선이므로, 선택 하이라이트를 제거하는 편이 UX 해석이 명확하기 때문.

### 검색 결과 클릭 후 트리 자동 확장 트리거를 `selectedKeys`로 보강 (2026-02-22)
- **문제**:
  - 검색 결과 클릭 후 `/search -> /`로 복귀할 때, 이미 같은 Space/경로가 선택돼 있던 경우 `selectedPath`/`selectedSpace` 값 변화가 없어 트리 자동 확장 effect가 실행되지 않을 수 있었다.
- **결정**:
  - `FolderTree`에 `selectedKeys` prop 변화 기반 자동 확장 effect를 추가한다.
  - `/search`에서는 `selectedKeys=[]`, browse에서는 `selectedKeys=[space-key]`가 되므로, `[] -> target` 전환을 신뢰 가능한 확장 신호로 사용한다.
- **이유**:
  - 라우트 전환 시점에서도 선택값이 같을 수 있는 케이스를 안정적으로 처리해, 검색 결과 클릭 후 트리의 열림/선택 상태를 파일 목록과 일관되게 유지할 수 있기 때문.

### 전역 검색 성능/정확도 1차 보정 전략 확정 (#128, 2026-02-22)
- **문제**:
  - 검색 요청마다 Space 순회 + 권한 조회 + 파일시스템 Walk가 반복되며, Space 수가 많을수록 지연이 커질 수 있었다.
  - 전역 limit를 수집 단계에서 먼저 차감해 Space 순서 편향으로 더 적합한 결과가 누락될 수 있었다.
  - 2글자 검색에서 path contains 매칭 비중이 높아 노이즈 결과가 상단에 노출되는 문제가 있었다.
- **결정**:
  - 검색 핸들러에서 optional batch resolver(`ResolveAccessibleSpaceIDs`)를 우선 사용해 권한 필터를 요청당 1회 계산한다. 미지원 access 구현은 기존 `CanAccessSpaceByID` fallback을 유지한다.
  - 결과 수집은 Space별 후보를 먼저 모은 뒤 전역 정렬하고 마지막에 limit를 절단한다.
  - 짧은 쿼리(2글자)는 path contains 매칭을 비활성화하고, path segment prefix 가중치를 name 매칭보다 낮은 우선순위로 반영한다.
- **이유**:
  - 기존 API 계약을 깨지 않고도 체감 성능과 결과 품질을 동시에 개선할 수 있으며, 권한 계층/테스트 호환성을 유지할 수 있기 때문.
  - 프론트 헤더 즉시검색은 타이핑 지연 체감을 줄이기 위해 호출 빈도 제어가 필요했다.
- **추가 결정 (프론트 헤더 즉시검색)**
  - 즉시결과 디바운스를 `220ms`에서 `420ms`로 상향한다.
  - 즉시결과 드롭다운 API 호출 최소 길이는 `2글자`로 유지한다.
  - Enter 전체검색(`/search`) 최소 길이도 `2글자`로 유지한다.
- **추가 이유**
  - 기존 검색 진입 규칙을 바꾸지 않으면서, 디바운스 상향만으로 호출 빈도를 완화하기 위해서다.

### 모바일 검색 헤더를 전면 전환 모드로 변경 (2026-02-22)
- **문제**:
  - 모바일에서 기존 헤더(메뉴/브랜드/상태/설정)를 유지한 채 입력창만 열면 검색 집중도가 낮고 터치 가능 영역이 좁아진다.
- **결정**:
  - 모바일에서 검색 아이콘을 누르면 헤더를 전용 검색 모드로 전환한다.
    - 일반 헤더 요소를 숨기고 `검색 닫기` 버튼 + 검색 입력만 전체 폭으로 노출
    - 닫기 시 즉시 기본 헤더로 복귀
  - 데스크톱 헤더 구조는 기존 그대로 유지한다.
- **이유**:
  - 작은 화면에서는 헤더를 검색 맥락으로 완전히 전환하는 것이 인지 부하가 낮고, 입력/드롭다운 조작 안정성이 높기 때문.

### 검색 결과 메타/아이콘 표기 단순화 및 통일 (2026-02-22)
- **문제**:
  - 검색 드롭다운/결과 테이블에 parent path가 함께 노출되면 정보 밀도가 과도해지고 가독성이 떨어진다.
  - 드롭다운 파일 아이콘이 테이블 아이콘 정책과 다르면 동일 결과를 다른 UI로 인지하게 된다.
- **결정**:
  - 검색 드롭다운 메타는 `spaceName`만 표시한다.
  - 검색 결과 테이블 메타는 `size | modTime | spaceName`만 표시하고 `parentPath`는 제거한다.
  - 드롭다운 파일 아이콘은 `FileTypeIcon`을 사용해 테이블과 동일 분류 규칙을 적용한다.
- **이유**:
  - 검색 결과에서는 위치 전체 경로보다 "어느 Space인지"가 1차 식별 정보로 충분하며, 동일 아이콘 규칙 유지가 인지 일관성을 높이기 때문.

### 기능 확장 사전 이슈 등록 정책 적용 (2026-02-22)
- **문제**:
  - 중대 기능(검색/삭제정책/쿼터/감사로그 등)을 코드 작업 전에 명확한 완료 조건 없이 진행하면 범위가 쉽게 확장되고 리뷰 기준이 흔들릴 수 있음.
- **결정**:
  - 다음 확장 항목을 작업 전 GitHub Issue로 선등록하고, 모든 구현은 해당 AC 기준으로 진행한다.
    - `#122` 전역 검색
    - `#123` 휴지통(Soft Delete)
    - `#124` 업로드 충돌 정책
    - `#125` Space 쿼터/대시보드
    - `#126` 감사 로그
- **이유**:
  - 요구사항/범위/검증 계획을 먼저 고정해야 병렬 작업과 리뷰가 가능하고, 회귀 리스크를 조기에 통제할 수 있기 때문.

### PR CI 기본 파이프라인 도입 (2026-02-22)
- **문제**:
  - 기존 저장소에는 태그 릴리즈 워크플로만 존재해, 일반 PR 단계에서 `lint/build/test` 회귀를 자동으로 막는 기본 CI가 없었다.
- **결정**:
  - `.github/workflows/ci.yml`을 추가해 `pull_request`와 `main` 브랜치 push에서 공통 검증을 수행한다.
  - 검증 순서를 `pnpm lint -> pnpm build -> apps/backend go test ./...`로 고정한다.
- **이유**:
  - 리뷰 이전에 정적검사/빌드/백엔드 테스트 실패를 조기 차단해 회귀 비용을 낮추고, PR 품질 기준을 자동화하기 위함.

### 탐색 UI 상태 처리 표준화 (2026-02-22)
- **문제**:
  - 폴더 탐색 화면에서 API 실패 시 이전 데이터/빈 상태/로딩 표시가 컴포넌트마다 달라 사용자가 현재 상태를 일관되게 인지하기 어려웠다.
- **결정**:
  - `FolderContent`와 `FolderTree`에 동일한 상태 우선순위를 적용한다.
    - 로딩(초기/빈 데이터): 중앙 로더
    - 실패(빈 데이터): 오류 메시지 + 재시도 버튼
    - 실패(기존 데이터 존재): 인라인 경고 + 재시도 버튼
    - 성공 + 빈 데이터: Empty 상태
  - API 오류 메시지는 공통 유틸(`apps/frontend/src/api/error.ts`)로 파싱한다.
- **이유**:
  - 동일한 상태를 동일한 시각 패턴으로 보여줘 UX 예측 가능성을 높이고, 운영 환경에서 오류 원인 파악/재시도 동선을 단순화하기 위함.

### 백엔드 인증/권한 테스트 확장 기준 확정 (2026-02-22)
- **문제**:
  - 기존 테스트는 일부 RBAC/부트스트랩 경로에 집중돼 있었고, 인증 토큰 수명주기와 미들웨어 권한 분기 회귀를 바로 탐지하기 어려웠다.
- **결정**:
  - `auth/service`와 `auth/middleware`의 핵심 분기(부트스트랩 필요, 로그인 성공/실패, refresh 토큰 검증, 공개 경로 우회, 401/403, claims 주입)를 단위 테스트로 추가한다.
  - `account/service`에는 Space 권한 계층(`read/write/manage`) 및 입력 검증(`userId mismatch`) 테스트를 추가한다.
- **이유**:
  - 인증/권한 경계는 회귀 영향도가 높아 최소 세트라도 핵심 정책 분기를 자동검증으로 고정해야 안정적인 릴리즈가 가능하기 때문.

### v0.1.0 릴리즈 노트 문서화 기준 확정 (2026-02-21)
- **문제**:
  - 자동 생성 릴리즈 본문과 별도로 사람이 읽기 쉬운 버전 요약 문서가 필요했다.
- **결정**:
  - `docs/releases/v0.1.0.md`를 추가해 `Highlights`, `New Features`, `Bug Fixes`, `Maintenance (Chore)`, `Security`, `Breaking Changes`, `Assets`, `Changelog` 구조로 정리한다.
- **이유**:
  - GitHub 릴리즈 편집 시 바로 재사용 가능한 기준 문서를 두면 릴리즈 품질과 일관성을 유지하기 쉽다.

### README 영문화 정책 적용 (2026-02-21)
- **문제**:
  - 저장소 주요 문서인 README가 한글 중심이라 해외 사용자/기여자 관점에서 온보딩 장벽이 있었다.
- **결정**:
  - `README.md`의 안내 문구를 영어로 전환한다.
  - 기존 섹션 구조와 명령어 예시는 유지하고 설명 텍스트만 영문화한다.
- **이유**:
  - 프로젝트 접근성을 높이고 GitHub 공개 저장소 표준 문서 톤에 맞추기 위함.

### GoReleaser changelog 생성 모드 전환 (2026-02-21)
- **문제**:
  - `v0.1.0` 릴리즈 본문이 `.github/release.yml` 카테고리 대신 git 커밋 목록(`## Changelog`) 형태로 생성됨.
- **결정**:
  - `.goreleaser.yaml`의 `changelog`를 `use: github-native`로 전환한다.
- **이유**:
  - GitHub native release notes API를 사용해야 `.github/release.yml` 카테고리 규칙이 적용되며, 사람이 기대한 섹션형 릴리즈 노트를 자동 생성할 수 있다.

### GitHub Actions 태그 기반 자동 릴리즈 파이프라인 확정 (2026-02-21)
- **문제**:
  - 태그를 푸시해도 릴리즈가 자동 실행되지 않아 운영자가 수동으로 GoReleaser를 실행해야 했다.
- **결정**:
  - `.github/workflows/release.yml`을 추가해 `v*` 태그 푸시 시 자동 릴리즈를 실행한다.
  - 워크플로에서 `pnpm install`, `pnpm release:check`, 백엔드 테스트 후 `goreleaser release --clean`을 수행한다.
- **이유**:
  - 릴리즈 실행 경로를 태그 이벤트에 고정하면 배포 재현성과 운영 일관성을 높일 수 있고, 수동 실행 누락 리스크를 줄일 수 있다.

### GitHub Release Notes 카테고리 구성 확정 (2026-02-21)
- **문제**:
  - 릴리즈 노트에 어떤 내용을 어떤 기준으로 쓸지 팀 기준이 없어서 버전별 메시지 품질 편차가 생길 수 있었다.
- **결정**:
  - `.github/release.yml`을 추가해 GitHub `Generate release notes` 기준 카테고리를 고정한다.
  - 카테고리: `New Features`, `Bug Fixes`, `Maintenance (Chore)`, `Other Changes`.
- **이유**:
  - 과도한 장문 대신 사용자 관점 핵심 섹션으로 일관되게 요약하고, PR 라벨 기반 자동 분류로 릴리즈 작성 비용을 낮추기 위함.

### GoReleaser 대상 플랫폼 표기/구성 확장 (2026-02-21)
- **문제**:
  - 기존 릴리즈 설정이 `darwin/windows`만 포함하여 Linux 사용자 대상 바이너리가 자동 생성되지 않았다.
- **결정**:
  - `.goreleaser.yaml`의 `goos`를 `darwin/linux/windows`로 확장하고, `goarch`는 기존 `amd64/arm64`를 유지한다.
- **이유**:
  - 배포 대상은 OS와 아키텍처를 함께 정의해야 실제 실행 호환성이 명확해진다.
  - macOS/Linux/Windows 사용자군을 공통 커버하면서 현대 환경의 주력 아키텍처(`amd64`, `arm64`)를 동시에 지원하기 위함.

### cross-space 이동/복사 목적지 권한 검증 보완 정책 확정 (2026-02-21, #117)
- **문제**:
  - 인증 미들웨어의 Space 권한 검증은 URL의 source `spaceId` 기준으로만 동작한다.
  - `move/copy`는 body의 `destination.spaceId`를 허용하지만, 기존 구현은 destination Space 쓰기 권한을 별도로 검증하지 않았다.
- **결정**:
  - `handleFileMove`/`handleFileCopy`에서 destination Space에 대한 `write` 권한 검증을 핸들러 레벨에서 추가한다.
  - 공통 헬퍼(`ensureSpacePermission`)로 `claims` + `CanAccessSpaceByID` 검증 로직을 재사용한다.
- **이유**:
  - cross-space 쓰기 경로는 URL 기반 미들웨어만으로 완전하게 커버되지 않으므로, 목적지 리소스 권한을 액션 처리 지점에서 명시적으로 강제해야 보안 경계가 닫힌다.

### 다운로드 티켓 경로 2차(단일 다운로드 통일) 정책 확정 (2026-02-21)
- **문제**:
  - 1차 도입 후에도 단일 다운로드는 여전히 `fetch -> blob` 경로를 사용해 메모리 피크 리스크가 남아 있었음.
- **결정**:
  - 단일 다운로드도 `download-ticket` API를 통해 티켓을 발급받고 네이티브 다운로드 URL로 실행하도록 통일한다.
  - 티켓 데이터에 `RemoveAfterUse` 플래그를 도입해 원본 파일과 임시 ZIP의 정리 정책을 분리한다.
- **이유**:
  - 단일/다중 다운로드 모두 동일한 전달 경로로 통일해야 프론트 메모리 사용 패턴을 예측 가능하게 만들고, 향후 다운로드 정책 확장(재시도/만료 관리)을 단일 지점에서 제어할 수 있기 때문.

### 다중/ZIP 다운로드 티켓 경로 1차 도입 정책 확정 (2026-02-21)
- **문제**:
  - 다중/ZIP 다운로드가 프론트 `fetch -> blob` 경로를 타면서 대용량 응답에서 JS 메모리 피크가 증가함.
- **결정**:
  - 다중 다운로드는 `download-multiple-ticket` API로 다운로드 티켓을 발급받고, `GET /api/downloads/{ticket}` 네이티브 다운로드 URL로 전환한다.
  - 티켓은 in-memory 저장소에서 TTL 기반으로 관리하며 1회 사용 후 폐기한다.
  - 단일 파일 다운로드는 1차 범위에서 기존 경로를 유지한다.
- **이유**:
  - 메모리 병목의 핵심 경로를 우선 제거하면서, 기존 단일 다운로드 UX 회귀 위험을 낮추는 단계적 전환이 가장 안전하기 때문.

### 다중선택 우클릭 메뉴 카운트 표기 통일 정책 확정 (2026-02-21)
- **문제**:
  - 데스크톱 우클릭 메뉴는 각 항목에 `N개`를 붙이고, 모바일은 상단 요약(`N개 선택됨`)만 표시해 카운트 전달 방식이 분산됨.
- **결정**:
  - 데스크톱 다중선택 우클릭 메뉴도 모바일과 동일하게 상단 요약 1줄(`N개 선택됨`)을 사용한다.
  - 각 액션 라벨(`다운로드`, `복사`, `이동`, `삭제`)에서는 `N개` 접미어를 제거한다.
- **이유**:
  - 동일한 선택 상태를 동일한 정보 구조(요약 + 액션)로 보여주는 편이 스캔 비용이 낮고, 플랫폼 간 인지 일관성이 높기 때문.

### 다운로드 완료 토스트 제거 정책 확정 (2026-02-21)
- **문제**:
  - 다운로드 성공 토스트가 브라우저 기본 다운로드 UX와 중복되어 화면 노이즈를 유발함.
- **결정**:
  - `handleBulkDownload` 성공 토스트를 제거한다.
  - 오류 상황(실패/권한 등) 토스트는 유지한다.
- **이유**:
  - 성공 알림은 브라우저 다운로드 UI로 충분하며, 실패 알림만 앱에서 명시하는 편이 간결하고 명확하기 때문.

### 다운로드 진행률 UI 제거 정책 확정 (2026-02-21)
- **문제**:
  - ZIP 다운로드는 서버에서 압축 파일 생성 완료 후 전송이 시작되어, 앱 내 진행률이 준비 대기 구간을 정확히 표현하지 못함.
  - 파일 탐색기 본문에 고정 플로팅 진행 UI를 유지할 필요성이 낮아짐.
- **결정**:
  - 프론트 다운로드 진행률 UI(퍼센트/바이트/플로팅 카드)를 제거한다.
  - 다운로드 상태 표시는 브라우저 기본 다운로드 UI에 위임한다.
- **이유**:
  - 사용자 동선을 단순화하고, ZIP 준비 구간에서 오해를 유발할 수 있는 앱 내 진행률 표시를 제거하기 위함.

### Status Hosts 주소 클릭 복사 정책 확정 (2026-02-21)
- **문제**:
  - 상태 팝오버의 `Hosts` 주소가 텍스트로만 노출되어 사용자 복사 동선이 길고, 접근 주소 공유가 번거로움.
- **결정**:
  - `Hosts` 항목을 클릭 가능한 버튼으로 렌더링해 단일 클릭으로 주소를 복사한다.
  - 클립보드 API 사용이 불가한 브라우저/권한 조건을 대비해 `execCommand('copy')` fallback을 함께 둔다.
- **이유**:
  - 상태 확인과 주소 공유 동선을 하나로 묶어 운영 편의성을 높이면서, 런타임 환경 편차(권한/브라우저)에 대한 실패율을 낮출 수 있기 때문.

### 다운로드 진행률 표시 정책 확정 (2026-02-20)
- **문제**:
  - 대용량 파일/압축 다운로드 시 완료까지 대기 시간이 길어도 사용자에게 진행 상태가 노출되지 않아 체감 불확실성이 높음.
- **결정**:
  - 프론트 다운로드 흐름을 `window.location` 직접 이동 방식에서 스트림 읽기 기반으로 전환해 `loadedBytes/totalBytes/percent`를 계산한다.
  - 백엔드 다운로드 응답은 가능한 경로에서 `Content-Length`를 보장한다.
    - 단일 파일: 파일 크기를 `Content-Length`로 전송
    - ZIP(폴더/다중): 임시 ZIP 파일 생성 후 크기 계산 뒤 전송
- **이유**:
  - 정확한 진행률 계산은 총 바이트 길이가 필요하므로, 응답 길이 제공을 서버 정책으로 고정하는 편이 UI 일관성과 신뢰성이 높다.
  - 진행률 UI는 파일 탐색 밀도를 해치지 않도록 본문 인라인 대신 `우측 하단 플로팅`이 더 적합하다.
  - 드롭다운/팝오버가 포털(`body`)에 렌더되는 구조를 고려해, 탐색 화면 활성 시에는 `body` 클래스 기반으로 오버레이 `user-select` 정책을 별도 제어하는 것이 일관적이다.

### 탐색 앱 쉘 우클릭 차단 정책 확정 (2026-02-20)
- **문제**:
  - 탐색 화면에서 우클릭 시 브라우저 기본 메뉴가 노출되어 커스텀 컨텍스트 메뉴 UX와 혼재됨.
  - 전체 차단 시 입력 필드(붙여넣기 등)의 기본 우클릭 사용성이 저하될 수 있음.
- **결정**:
  - `MainLayout` 캡처 단계에서 기본 우클릭 메뉴를 차단한다.
  - 커스텀 컨텍스트 메뉴가 정의된 위치에서는 기존 핸들러를 그대로 사용한다.
  - `input`, `textarea`, `[contenteditable]`, `.allow-native-context-menu`는 우클릭 차단 예외로 둔다.
- **이유**:
  - 탐색 UX 일관성을 유지하면서, 텍스트 입력/편집의 기본 OS 컨텍스트 메뉴는 보존하기 위함.

### 탐색 앱 쉘 텍스트 선택 차단 범위 확정 (2026-02-20)
- **문제**:
  - 파일/폴더 드래그 및 박스선택 중 의도치 않은 텍스트 하이라이트가 발생해 상호작용 집중도가 떨어짐.
  - 전역(서비스 전체) 차단은 로그인/설정 등 일반 UI 텍스트 사용성을 저해할 수 있음.
- **결정**:
  - Google Drive 스타일로 **탐색 앱 쉘(MainLayout) 범위**에서만 `user-select: none`을 상시 적용한다.
  - 편집 가능 요소(`input`, `textarea`, `[contenteditable]`)는 `user-select: text`로 예외 처리한다.
- **이유**:
  - 드래그 안정성은 확보하면서, 텍스트 입력/편집 UX는 유지하는 최소 침습 정책이기 때문.

### 라이선스 정책 확정: AGPL-3.0-only (2026-02-20)
- **문제**:
  - 프로젝트의 공개 범위와 파생 서비스(특히 네트워크 제공형)의 소스 공개 의무 수준을 명확히 정할 필요가 있었음.
- **결정**:
  - 프로젝트 기본 라이선스를 `GNU Affero General Public License v3.0 (AGPL-3.0-only)`로 확정한다.
  - 루트 `LICENSE` 파일을 추가하고 README 라이선스 섹션을 확정 문구로 갱신한다.
- **이유**:
  - 사용자 목표인 “기여는 허용하되, 파생 서비스가 비공개로 변종 운영되는 경우를 줄이고 공식 프로젝트 중심으로 사용을 유도”하는 정책에 가장 부합하기 때문.

### README 오픈소스 문서 톤 재정비 (2026-02-20)
- **문제**:
  - 기존 README가 현재 구현 범위와 불일치(예: SMB/NFS 지원 표기)하고, 실행/설정/보안 가이드가 부족해 신규 사용자의 온보딩 품질이 낮았음.
- **결정**:
  - README를 실제 동작 기준으로 전면 개편한다.
  - 프로토콜 범위를 `WEB/WebDAV/SFTP`로 명시하고 미지원 항목(`SMB/NFS`, 내장 HTTPS 종단 부재)을 명확히 선언한다.
  - Quick Start, 설정/환경변수, 보안 권장사항(리버스 프록시 TLS), 릴리즈/기여/로드맵을 추가한다.
  - 저장소에 `LICENSE` 파일이 없는 현 상태를 README에 명시한다.
- **이유**:
  - 오픈소스 저장소에서 README는 사실상의 제품 명세서이므로, 기능 과장/불일치를 줄이고 재현 가능한 실행 절차를 우선 제공해야 하기 때문.
- **후속 조정**:
  - 사용자 피드백에 따라 README에서 이모티콘/장식 표현을 제거하고, 릴리즈 표현은 Build 중심으로 통일했다.
  - 설정 파일 YAML 예시는 삭제하고 운영 관점 메모(위치/동작)만 남겼다.
  - 2차 피드백에 따라 미지원 항목 블록, 프로젝트 구조, 운영 메모 섹션을 제거하고 목표 문구를 `내 PC/서버 파일을 쉽고 단순하게 관리/공유`로 재정의했다.
  - 라이선스 문구는 정책 확정 전 상태로 단순화하고, 라이선스 유형은 별도 의사결정으로 분리한다.

### 파일 확장자별 아이콘 썸네일 1차 도입 (2026-02-20)
- **문제**:
  - 파일 탐색기에서 이미지를 제외한 모든 파일이 동일 아이콘(`FileOutlined`)으로 표시되어 파일 종류를 빠르게 구분하기 어려움.
- **결정**:
  - 확장자 기반 카테고리 유틸(`getFileCategory`)을 도입해 `pdf/word/excel/ppt/archive/audio/video/code/text/default`로 분류한다.
  - 공통 아이콘 컴포넌트(`FileTypeIcon`)를 신설하고 Grid/Table 양쪽 렌더에서 재사용한다.
  - 이미지 파일은 기존 실제 이미지 썸네일(`ImageThumbnail`) 경로를 유지한다.
- **이유**:
  - UI 복잡도 증가 없이 파일 식별 속도를 높일 수 있고, 아이콘 정책을 한 곳에서 유지보수할 수 있기 때문.
- **후속 조정**:
  - 미분류 확장자는 `FileUnknownOutlined(?)` 대신 `FileOutlined`를 사용한다.
  - 이유: 일반 사용자 관점에서 `?`는 오류/누락으로 인지될 수 있어, 기본 파일 아이콘이 더 중립적이고 예측 가능하다.

### `http_enabled` 설정 필드 제거 (2026-02-20)
- **문제**:
  - HTTP 서버는 현재 아키텍처에서 필수 경로(API/SPA/WebDAV 베이스)인데, `http_enabled` 토글은 실제 런타임 제어에 사용되지 않아 설정 의미가 불명확함.
- **결정**:
  - 백엔드 설정 모델/기본 config YAML/API 응답 모델에서 `http_enabled`를 제거한다.
  - 프론트 서버 설정 화면에서도 HTTP 활성화 토글을 제거하고 포트 설정만 유지한다.
  - WebDAV UI의 `httpEnabled` 의존 조건을 제거한다.
- **이유**:
  - 실제 동작과 불일치한 데드 설정을 제거해 운영 혼선을 줄이고, 서버 설정을 `port + webdav + sftp`의 유효 제어 항목으로 단순화하기 위함.

### 모노레포 `config/secrets` Git 제외 범위 확장 (2026-02-20)
- **문제**:
  - 백엔드 하위(`apps/backend/config/secrets`)는 개별 `.gitignore`로 제외되지만, 모노레포 루트 기준의 `config/secrets` 생성 경로는 전역 제외 규칙이 없어 실수로 추적될 여지가 있음.
- **결정**:
  - 루트 `.gitignore`에 `**/config/secrets/` 패턴을 추가해 모든 워크스페이스의 `config/secrets`를 일괄 제외한다.
- **이유**:
  - SFTP host key/JWT secret 같은 런타임 생성 비밀키 파일의 Git 유출 위험을 경로 편차와 무관하게 차단하기 위함.

### Status 팝오버 섹션 순서 재구성 (2026-02-20)
- **문제**:
  - 접속 URL(로컬/LAN)과 프로토콜 상태가 한 흐름으로 섞여 보여 정보 그룹이 직관적이지 않음.
- **결정**:
  - `Status` 팝오버를 `Hosts` 섹션(상단)과 `Protocols` 섹션(하단)으로 분리한다.
- **이유**:
  - “어디로 접속할지(Host)”와 “어떤 프로토콜이 정상인지(Status)”를 분리해 스캔 속도를 높이기 위함.

### Status 프로토콜 경로 표기 슬래시 정리 (2026-02-20)
- **문제**:
  - 상태 팝오버에서 `WEB`의 `:포트/`, `WebDAV`의 `:포트/dav/`처럼 끝 슬래시가 표시되어 정보 대비 시각 노이즈가 있었음.
- **결정**:
  - 프로토콜 경로 표기를 정규화해 루트(`/`)는 숨기고, 비루트 경로는 끝 슬래시를 제거해 표시한다.
- **이유**:
  - 정보량은 유지하면서 표기 밀도를 줄여 가독성을 높이기 위함.

### FTP 기능 제거 및 SFTP 단일화 (2026-02-20)
- **문제**:
  - 일반 사용자 대상 실행 환경에서 FTP(평문) 노출은 보안/운영 복잡도를 높이며, SFTP가 동일 목적을 충족함.
- **결정**:
  - 백엔드 FTP 모듈(`internal/ftp`)과 서버 lifecycle 연동을 제거한다.
  - 설정 모델/기본 설정 파일에서 `ftp_enabled`, `ftp_port`를 제거한다.
  - 상태 API 및 프론트 서버 설정/상태 팝오버에서 FTP 항목을 제거한다.
- **이유**:
  - 프로토콜 표면을 줄여 보안 리스크를 낮추고, 사용자 안내를 SFTP 중심으로 단순화하기 위함.

### Status 프로토콜 렌더 순서 고정 (2026-02-19)
- **문제**:
  - 서버 상태 팝오버가 `Object.entries(protocols)` 순회에 의존해 프로토콜 표시 순서가 의도와 다르게 보일 수 있음.
- **결정**:
  - 프론트 `ServerStatus`에 고정 순서 배열(`http`, `webdav`, `sftp`)을 두고, 해당 순서로 먼저 렌더한다.
  - 고정 배열에 없는 프로토콜 키는 뒤에 이어서 표시한다.
- **이유**:
  - 사용자 인지 순서(`WEB -> WebDAV -> SFTP`)를 항상 동일하게 유지하면서, 추후 프로토콜 추가 시에도 확장성을 보존하기 위함.

### 데스크톱 wheel 스크롤 입력 경로 단일화 (2026-02-20)
- **문제**:
  - 파일 리스트 스크롤 컨테이너와 툴바/경로바가 형제 레이어로 분리돼 있어, wheel 입력 위치에 따라 리스트가 스크롤되지 않는 체감이 발생.
- **결정**:
  - `FolderContent` 루트 `onWheelCapture`에서 데스크톱 wheel을 정규화해 `selectionContainer.scrollTop`을 직접 갱신한다.
  - 모달/드롭다운/BottomSheet, 독립 스크롤 영역은 예외 처리해 기존 컴포넌트 스크롤 동작을 보존한다.
- **이유**:
  - 브라우저 기본 버블링/스크롤 체인에 의존하면 레이어 구조에 따라 입력 누락이 발생하므로, 파일 탐색 영역은 단일 스크롤 경로를 명시적으로 보장하는 편이 안정적이다.

### SFTP 서버 1차 확장 방식 확정 (2026-02-19)
- **문제**:
  - FTP는 구현돼 있지만 SFTP는 설정/UI만 존재해 실제 운영 프로토콜 선택지가 제한됨.
  - 로컬/단일 실행 환경에서는 루트 권한 없이 동작 가능한 기본 포트 정책이 필요함.
- **결정**:
  - `internal/sftp` 모듈을 신설하고 `gliderlabs/ssh + pkg/sftp` 조합으로 구현한다.
  - 인증은 기존 계정 서비스(`account.Authenticate`)를 재사용하고, 파일 접근은 Space 권한(`read/write`) 정책을 동일 적용한다.
  - 가상 루트는 FTP와 동일하게 `/{spaceName}/...` 구조를 유지해 Space 경계를 강제한다.
  - host key는 자동 생성/재사용하며, 운영 오버라이드는 `COHESION_SFTP_HOST_KEY_FILE`로 허용한다.
  - 기본 SFTP 포트는 `22`가 아닌 비특권 포트 `2222`로 통일한다.
- **이유**:
  - 기존 계정/권한 도메인을 그대로 재사용해 인증 정책 일관성을 확보할 수 있고, macOS/Windows 일반 사용자 실행에서도 추가 권한 없이 안정적으로 동작하기 때문.

### React Hooks lint 규칙 대응 방식 확정 (2026-02-19)
- **문제**:
  - `react-hooks/set-state-in-effect`, `react-hooks/refs` 규칙으로 `BottomSheet`, `FolderContent`가 lint 실패.
- **결정**:
  - effect 본문의 동기 `setState`는 프레임 스케줄(`requestAnimationFrame`)로 전환한다.
  - 렌더 단계의 `ref.current` 측정은 금지하고, DOM 측정은 `useLayoutEffect`로 이동한다.
  - 오버레이 위치 계산은 `ResizeObserver + scroll/resize listener` 기반으로 유지한다.
- **이유**:
  - React Hooks 규칙을 만족하면서 기존 UX(드래그/오버레이 위치/히스토리 동작)를 최대한 보존하는 최소 변경 경로이기 때문.

### 보안 하드닝 1차 구현 정책 확정 (#95, 2026-02-19)
- **문제**:
  - 보안 점검에서 WebDAV 인증 경계 부재, 설정 API 민감정보 노출, 초기 관리자 fallback, 의존성 취약점이 확인됨.
- **결정**:
  - WebDAV는 API 쿠키 세션 대신 **Basic Auth + Space 권한 검증**으로 보호한다.
  - WebDAV 루트 목록은 인증 사용자 기준 접근 가능한 Space만 노출한다.
  - `webdav_enabled`는 설정값 표시용이 아니라 실제 라우트 등록/상태판정에 반영한다.
  - `/api/config`는 `server`만 반환/갱신하고 datasource는 API 변경 범위에서 제외한다.
  - 기본 관리자 fallback은 제거하고, 초기 관리자 생성은 최초 실행 setup 또는 운영자 환경변수 주입으로 처리한다.
  - 프론트/백엔드 의존성은 즉시 패치(`react-router`, Go toolchain) 후 재스캔한다.
- **이유**:
  - 외부 노출 프로토콜(WebDAV)과 운영 민감정보(API config)는 공격 표면 우선순위가 가장 높아 1차 릴리즈에서 즉시 차단/축소가 필요하다.

### 클릭 실행 UX 기준 초기 관리자 보안 부팅 정책 개정 (2026-02-19)
- **문제**:
  - 고정 기본 자격증명(`admin/admin1234`)은 범용 배포 환경에서 계정 탈취 리스크를 높임.
  - 반대로 환경변수만 강제하면 일반 소비자 대상 더블클릭 실행에서 첫 구동 UX가 저하됨.
- **결정**:
  - 기본 관리자 fallback(`admin/admin1234`)을 완전히 제거한다.
  - 관리자 계정이 없으면 인증 전에 setup 상태를 반환하고(`428 Precondition Required`), 최초 실행 공개 API로 관리자 1회 생성을 처리한다.
    - `GET /api/setup/status`
    - `POST /api/setup/admin`
  - 운영자 자동 부팅이 필요한 경우에만 `COHESION_ADMIN_USER` + `COHESION_ADMIN_PASSWORD`를 함께 지정해 1회 계정 생성한다.
- **이유**:
  - "기본 취약 계정 제거"와 "클릭 실행 UX 유지"를 동시에 만족하는 최소 운영 정책이기 때문.

### JWT 시크릿/SQLite 파일 보관 정책 하드닝 (2026-02-19)
- **문제**:
  - 배포 환경에서 JWT 시크릿이 미설정되면 고정값 사용 위험이 있고, SQLite 파일이 넓은 권한으로 생성되면 로컬 노출 면적이 커짐.
- **결정**:
  - `COHESION_JWT_SECRET` 미지정 시 암호학적 난수 기반 시크릿을 파일에 자동 생성/보관한다.
    - 기본 경로: 사용자 설정 디렉토리 하위 `Cohesion/secrets/jwt_secret`
    - 커스텀 경로: `COHESION_JWT_SECRET_FILE`
  - 시크릿 파일/디렉토리 권한은 각각 `0600`/`0700`으로 제한한다.
  - SQLite 디렉토리/DB 파일 권한도 각각 `0700`/`0600`으로 강제한다(Windows 제외).
- **이유**:
  - SQLite 자체 계정/비밀번호 모델이 없는 구조에서 현실적인 1차 방어선은 파일 시스템 권한 최소화이기 때문.

### 실행 문서 환경변수 안내 정합화 (2026-02-19)
- **문제**:
  - 실행 문서(`AGENTS.md`, `GEMINI.md`, `CLAUDE.md`)가 `ENV`, `DB_PATH`, `PORT`를 백엔드 환경변수로 안내하고 있었지만, 실제 코드는 해당 키를 사용하지 않음.
- **결정**:
  - 문서의 환경변수 항목을 코드 기준으로 정리:
    - 사용 중: `COHESION_JWT_SECRET`, `COHESION_JWT_SECRET_FILE`, `COHESION_ADMIN_USER`, `COHESION_ADMIN_PASSWORD`, `COHESION_ADMIN_NICKNAME`
    - 미사용: `ENV`, `DB_PATH`, `PORT`
  - DB 기본 경로도 `config.dev/prod.yaml`의 `database.url` 기준으로 명시.
- **이유**:
  - 설치/운영 시 문서-코드 불일치로 인한 오설정을 방지하고, 실행 절차를 단순화하기 위함.

### GoReleaser 도입 및 멀티플랫폼 릴리즈 파이프라인 구성 (2026-02-19)
- **문제**:
  - 운영 빌드가 단일 `build.js` 기반으로만 관리되어 macOS/Windows 대상 릴리즈 산출물을 일관된 규칙으로 생성/배포하기 어려웠음.
  - 프론트 정적 리소스 임베드 준비가 백엔드 빌드 스크립트에만 묶여 있어 릴리즈 자동화 경로에서 재사용이 어려웠음.
- **결정**:
  - 루트에 `.goreleaser.yaml`을 추가해 `darwin(amd64/arm64)`, `windows(amd64)` 대상 빌드/아카이브/체크섬 생성을 표준화한다.
  - Go 빌드 플래그는 `-tags=production`, `-X main.goEnv=production`을 고정해 운영 모드 산출물을 생성한다.
  - 프론트 빌드 산출물 복사를 `apps/backend/scripts/prepare-web-dist.js`로 분리해 `build.js`와 GoReleaser `before` hook에서 공통 사용한다.
- **이유**:
  - 릴리즈 품질(반복 가능성/재현성)과 배포 속도를 높이고, 플랫폼별 수동 빌드 실수를 줄이기 위함.

### 설정 파일 탐색 기준을 실행파일 위치 기반으로 전환 (2026-02-19)
- **문제**:
  - 기존 `SetConfig`는 `viper.AddConfigPath(\"config\")`만 사용해, 실행 위치(CWD)에 따라 `config.dev/prod.yaml` 탐색 경로가 달라짐.
  - 이로 인해 바이너리를 다른 디렉토리(예: 사용자 홈)에서 실행하면 설정 파일을 찾지 못해 부팅이 실패함.
- **결정**:
  - `SetConfig`에서 config 탐색 경로를 실행파일 기준으로 우선 적용:
    - `<exe>/config`
    - `<exe>/../config`
  - 개발 편의를 위해 `cwd/config`를 fallback으로 유지.
  - 설정 파일이 없는 경우, 우선 탐색 경로에 기본 `config.dev.yaml`/`config.prod.yaml`을 자동 생성 후 로딩한다.
  - 설정 로더는 `viper.Reset()` 후 경로를 다시 구성해 재시작 시점에도 일관된 탐색을 보장.
- **이유**:
  - 사용자 실행 위치와 무관하게 설치된 바이너리가 안정적으로 설정 파일을 찾도록 만들기 위함.

### 전체 보안점검 기준 및 후속 우선순위 확정 (2026-02-19)
- **문제**:
  - 최근 기능 추가 이후 인증/권한/파일처리 경계와 의존성 취약점 누적 여부를 한 번에 검증할 필요가 있음.
- **결정**:
  - 점검 범위를 `코드(인증/인가/경로검증) + 설정(노출/활성화 플래그) + 의존성 스캔`으로 통합한다.
  - 실행 기준 명령은 `pnpm audit --prod`, `govulncheck ./...`, `rg` 패턴 점검으로 고정한다.
  - 후속 조치 우선순위를 다음과 같이 확정한다:
    1) WebDAV 인증 강제 및 `webdav_enabled` 플래그 적용
    2) 기본 관리자 초기값 하드닝 (fallback 제거)
    3) `react-router`/Go 런타임 보안 패치
    4) `/api/config` 민감정보 비노출 및 에러 응답 하드닝
- **이유**:
  - 외부 노출 경로(`HTTP/WebDAV/FTP`)와 파일 I/O 경계를 우선 차단하는 것이 실제 침해 가능성을 가장 빠르게 낮춘다.

### 다크모드 드래그 선택영역 농도 상향 (2026-02-19)
- **문제**:
  - 다크모드에서 드래그 오버레이가 다소 연해 선택 영역이 약하게 느껴진다는 피드백이 있음.
- **결정**:
  - `AntdApp`에 현재 테마 클래스(`app-theme-dark`/`app-theme-light`)를 부여한다.
  - `.ant-app.app-theme-dark`에서만 `--browse-selection-overlay-bg`를 `40%` 농도로 상향한다.
- **이유**:
  - 라이트 대비를 유지하면서 다크모드에서만 선택 영역 시인성을 강화할 수 있다.

### 파일 익스플로러 드래그 선택영역 다크/라이트 적응 (2026-02-19)
- **문제**:
  - 드래그 오버레이 반투명 값이 고정 RGBA라 다크/라이트 전환 시 농도 체감이 일관되지 않을 수 있음.
- **결정**:
  - `.ant-app` 범위에서 `--browse-selection-overlay-bg`를 `color-mix(in srgb, var(--ant-control-item-bg-active) 28%, transparent)`로 설정해 현재 테마 선택 토큰을 기준으로 자동 계산한다.
- **이유**:
  - 별도 모드 분기 없이도 선택 오버레이가 테마 선택색과 같은 축을 따라가며, 다크/라이트 모두에서 과하거나 약한 인상을 줄일 수 있다.

### 파일 익스플로러 드래그 선택영역 반투명 조정 (2026-02-19)
- **문제**:
  - 완전 투명 오버레이는 드래그 범위 인지가 약해 선택 영역 파악이 어렵다는 피드백이 있음.
- **결정**:
  - 박스 선택 오버레이 배경을 약한 반투명 값(`--browse-selection-overlay-bg`)으로 적용한다.
  - 테두리 강조는 유지해 선택 경계를 명확히 한다.
- **이유**:
  - 콘텐츠 가독성을 유지하면서도 드래그 중 선택 영역을 직관적으로 인지할 수 있다.

### 파일 익스플로러 드래그 선택영역 투명화 (2026-02-19)
- **문제**:
  - 파일 익스플로러에서 박스 선택 드래그 시 오버레이 배경이 불투명하게 보여 콘텐츠 가독성이 떨어짐.
- **결정**:
  - `BoxSelectionOverlay`의 배경색을 제거(`transparent`)하고 선택 사각형 테두리만 유지한다.
- **이유**:
  - 드래그 중에도 파일 목록 정보를 계속 읽을 수 있어 선택 작업의 시인성과 조작 감이 개선된다.

### 트리 폴더 아이콘/텍스트 정렬 보정 (2026-02-19)
- **문제**:
  - `FolderTree`에서 폴더 아이콘(`switcherIcon`)이 텍스트보다 위쪽에 배치되어 모든 트리 뷰에서 수직 정렬이 어긋나 보임.
- **결정**:
  - `FolderTree` 루트에 전용 클래스(`folder-tree`)를 부여하고, 스위처/아이콘/placeholder를 CSS 클래스로 정리한다.
  - `.folder-tree .ant-tree-switcher`를 `inline-flex + align-items:center`로 고정해 아이콘 수직 중심을 텍스트 라인 중심에 맞춘다.
- **이유**:
  - 트리 선택/탐색 UI에서 행 단위 시각 정렬이 어긋나면 정보 스캔 속도와 완성도가 떨어지므로 공통 컴포넌트 레벨에서 일괄 보정하는 것이 유지보수와 일관성에 유리하다.

### 선택 상태 색상 공통화 (2026-02-19)
- **문제**:
  - Space 트리 선택, 설정 메뉴 선택, 파일 브라우즈 선택이 서로 다른 색상 소스를 사용해 동일한 `selected` 상태가 일관되지 않게 보임.
- **결정**:
  - 테마에 선택 토큰(`selection bg/hover/text`)을 정의하고, `Menu`/`Tree` 컴포넌트 토큰을 해당 값으로 통일한다.
  - 전역 토큰 `controlItemBgActive`, `controlItemBgHover`를 동일 선택 토큰으로 설정한다.
  - 브라우즈 선택 변수는 `:root` 기본값을 유지하되 `.ant-app` 레벨에서 Ant CSS 변수(`--ant-control-item-bg-active`, `--ant-control-item-bg-hover`)를 참조하도록 재선언한다.
- **이유**:
  - 동일 의미 상태(`selected`)는 색상 체계를 공유해야 UX 학습 비용이 줄고, 다크/라이트 전환에서도 가시성을 안정적으로 유지할 수 있다.

### 선택 외곽선/그림자 강조 제거 (2026-02-19)
- **문제**:
  - 다크모드 가시성 보정 과정에서 추가된 선택 외곽선/그림자 스타일이 UI 톤과 맞지 않는다는 피드백이 있음.
- **결정**:
  - 테이블 선택 행의 inset 외곽선(`box-shadow`)을 제거한다.
  - 그리드 선택 카드의 경계선/그림자(`borderColor`, `boxShadow`)를 제거한다.
  - 선택 표시는 배경색 강조만 유지한다.
- **이유**:
  - 사용자 선호에 맞춰 과한 강조를 줄이면서도 선택 상태의 기본 가시성은 유지할 수 있다.

### 모바일 터치 스크롤 및 다크모드 선택 가시성 보정 (2026-02-19)
- **문제**:
  - 모바일 파일 익스플로러에서 터치 스크롤 제스처가 매끄럽지 않거나 간헐적으로 먹지 않는 체감이 있음.
  - 다크모드에서 선택 강조(그리드/테이블)와 뷰 전환 버튼 활성 상태가 배경과 유사해 식별성이 낮음.
- **결정**:
  - 파일 목록 스크롤 컨테이너에 `touchAction: pan-y`, `WebkitOverflowScrolling: touch`를 적용한다.
  - 모바일 카드/행의 `onTouchMove` 핸들러를 제거하고, 컨테이너 스크롤 시 롱프레스 타이머를 해제해 제스처 간섭을 줄인다.
  - 선택 강조 변수(`--browse-selection-bg`, `--browse-selection-border-color`)의 대비를 상향하고, 테이블 선택 행에 inset 경계 강조를 추가한다.
  - 그리드/테이블 뷰 전환 버튼은 토큰 기반 활성/비활성 스타일을 분리해 다크모드 대비를 강화한다.
- **이유**:
  - 모바일 스크롤은 브라우저 기본 pan 제스처 우선 처리가 중요하며, 불필요한 touch-move 핸들러는 스크롤 체감 저하 요인이 될 수 있다.
  - 다크 테마에서는 배경 계열이 근접하므로 선택 상태를 색/경계/텍스트 대비로 명확히 분리해야 조작 인지성이 유지된다.

### 블루-그레이 팔레트 전역 테마 적용 (2026-02-19)
- **문제**:
  - 페이지별로 `ConfigProvider`가 분산되어 로그인 라우트가 동일 테마 컨텍스트를 받지 못함.
  - 하드코딩 색상(`#1890ff`, `#ffca28`, `#8c8c8c` 등)이 여러 컴포넌트에 흩어져 팔레트 일관 적용이 어려움.
  - Ant CSS 변수 참조가 camelCase(`--ant-colorBgLayout`)로 되어 있어 실제 변수(`--ant-color-bg-layout`)와 불일치가 존재함.
- **결정**:
  - 루트 엔트리에서 단일 `ConfigProvider`를 적용하고, 팔레트 기반 `buildCohesionThemeConfig`(light/dark)를 사용한다.
  - `MainLayout`, `Settings`의 개별 `ConfigProvider` 래핑을 제거해 전역 테마를 단일 소스로 유지한다.
  - 공통 색상은 커스텀 CSS 변수(`--app-folder-icon-color`, `--browse-selection-*`)와 Ant 토큰(`token.color*`) 중심으로 치환한다.
  - Ant CSS 변수 참조를 kebab-case로 정정해 토큰값 반영을 보장한다.
- **이유**:
  - 라우트 전체의 테마 일관성과 유지보수성을 높이고, 향후 테마 조정 시 수정 지점을 루트 시드/토큰으로 한정할 수 있다.

### 로그인 화면 배경 회색 처리 (2026-02-19)
- **문제**:
  - 로그인 화면 배경이 기본 흰색이라 카드 경계 대비가 약하고 화면이 비어 보인다는 피드백이 있음.
- **결정**:
  - 로그인 페이지 래퍼(`.login-page`) 배경을 공통 Ant 토큰 `--ant-color-bg-layout`로 적용하고, fallback으로 `#f2f3f1`를 둔다.
- **이유**:
  - 배경 대비를 높이면서 테마 토큰과 연동해 공통 스타일 일관성을 유지할 수 있다.

### 모바일 설정 테이블/하단 잘림/테이블 멀티선택 보정 (2026-02-18)
- **문제**:
  - 설정 > 계정관리의 테이블이 모바일 폭에서 깨져 조작성이 떨어짐.
  - 모바일에서 콘텐츠가 화면을 꽉 채울 때 하단 일부가 잘려 보이는 사례가 존재함.
  - 폴더콘텐츠 테이블 뷰에서 연속 멀티선택 동작이 일관되지 않음.
- **결정**:
  - `AccountSettings` 테이블에 모바일 대응(`scroll.x`, `ellipsis`, 액션 버튼 `wrap`)을 적용한다.
  - 공통 레이아웃 높이를 `100dvh`로 보정하고 스크롤 컨테이너에 safe-area 하단 패딩을 추가한다.
  - `FileExplorer`의 `100vh` 고정 높이를 제거해 부모 레이아웃 높이를 따르게 한다.
  - `useFileSelection`의 선택 앵커를 ref로 추적해 shift 범위선택/연속 선택 안정성을 높인다.
- **이유**:
  - 기기 폭/모바일 브라우저 UI 변화(주소창, 홈 인디케이터)로 인한 레이아웃 오차를 줄이고, 멀티선택 UX를 일관되게 유지하기 위함.

### BottomSheet 액션 메뉴 아이콘 정렬 보정 (2026-02-18)
- **문제**:
  - 모바일 BottomSheet 및 테이블 컨텍스트 메뉴에서 `이동`(Material Symbols) 아이콘의 폭/베이스라인이 다른 Ant 아이콘과 달라 행 정렬이 어긋나 보임.
- **결정**:
  - `move-action-icon` 공통 클래스를 추가해 아이콘 박스(`1em`)와 baseline을 고정한다.
  - `FolderContent`, `FolderContentTable`의 `drive_file_move` 아이콘에 동일 클래스를 적용한다.
- **이유**:
  - 아이콘 세트 혼용 시에도 메뉴 항목별 텍스트 시작점과 수직 정렬을 일관되게 유지할 수 있다.

### 공통 헤더 높이 소폭 축소 (2026-02-18)
- **문제**:
  - 메인/설정 공통 헤더가 상대적으로 높아 콘텐츠 영역이 줄어든다는 피드백이 있음.
- **결정**:
  - 전역 공통 클래스 `layout-header` 높이를 `56px`로 조정한다.
- **이유**:
  - 페이지 전반의 상단 밀도를 균일하게 줄이면서도 기존 버튼/브랜드 가독성을 유지할 수 있다.

### 파일 익스플로러 좌우 여백 드래그 시작 범위 보정 (2026-02-18)
- **문제**:
  - 박스선택 시작 컨테이너가 그리드 전용 래퍼에 한정되어, 파일 익스플로러 좌우 여백에서 드래그 시작이 누락되는 체감이 발생.
- **결정**:
  - 박스선택 `containerRef`를 공통 콘텐츠 스크롤 래퍼(`selectionContainerRef`)로 변경한다.
  - `FileExplorer`의 외곽 패딩(`16px`)은 유지하고, `selectionContainerRef`에 음수 마진 + 동일 내부 패딩을 적용해 외곽 여백을 선택 컨테이너 영역에 포함한다.
  - 박스선택 활성은 기존 정책(PC 그리드 전용)을 유지한다.
- **이유**:
  - 시각적 여백은 유지하면서도 사용자가 인지하는 좌우 여백에서 드래그 시작이 가능해져 체감 일관성을 높일 수 있다.

### 모바일/PC 선택모드 상단 로우 고정 높이 전환 (2026-02-18)
- **문제**:
  - 모바일/PC에서 선택바가 나타나고 사라질 때 상단 영역 높이가 변해 본문이 밀리는 점프가 발생.
- **결정**:
  - 상단 툴바 슬롯 높이를 고정하고(모바일 `44px`, PC `52px`), 기본 툴바와 선택바를 동일 슬롯에서 교체 렌더링한다.
  - 선택바는 `nowrap + overflow-x:auto`로 단일 높이를 유지한다.
  - `FolderContentToolbar`에 `compact` 옵션을 추가해 모바일/PC 공통 한 줄 슬롯 레이아웃을 적용한다.
- **이유**:
  - 선택 상태 전환 시 레이아웃 변동을 줄여 모바일/데스크톱 모두에서 시각적 안정성을 높일 수 있다.

### 상단 고정 툴바 여백 보정 (2026-02-18)
- **문제**:
  - 툴바 하단 여백 확대는 의도와 달리 본문 간격만 증가시키고, 사용자가 원한 상단 고정 상태의 헤더 간격 개선과 맞지 않음.
- **결정**:
  - 파일 목록 컨테이너 상단 패딩은 기본값(`16px`)으로 유지한다.
  - 상단 툴바 슬롯 자체에 `marginTop: 8px`를 적용해 고정 툴바의 상단 여백을 확보한다.
- **이유**:
  - 본문 밀도는 유지하면서, 고정 툴바가 상단 헤더에 붙어 보이는 인상을 완화할 수 있다.

### BottomSheet 모바일 액션시트 최대 높이 조정 (2026-02-17)
- **문제**:
  - 액션시트 최대 높이가 `56%`로 제한되어, 긴 목록에서 시트가 충분히 확장되기 전에 내부 스크롤이 발생함.
- **결정**:
  - `BottomSheet`의 `snapPoints` 유효 범위를 `0 < p <= 1`로 조정해 `1`을 허용한다.
  - `FolderContent`의 모바일 액션시트 `snapPoints`를 `0.56`에서 `1`로 변경한다.
- **이유**:
  - 짧은 콘텐츠는 자연 높이만 사용하고, 긴 콘텐츠는 화면 최대 높이까지 확장된 뒤 스크롤이 시작되어 모바일 BottomSheet UX 기대치에 맞는다.

### BottomSheet 스크롤 재현용 임시 아이템 추가 (2026-02-17)
- **문제**:
  - 모바일 BottomSheet 스크롤/드래그 전환 UX를 검증하려면 충분한 스크롤 길이가 필요함.
- **결정**:
  - 모바일 선택 액션 BottomSheet 메뉴에 테스트용 임시 아이템 30개를 하단에 추가한다.
- **이유**:
  - 테스트 데이터 의존 없이 즉시 스크롤 구간을 확보해 터치 상호작용을 반복 검증할 수 있다.

### BottomSheet 테스트용 임시 아이템 제거 (2026-02-18)
- **문제**:
  - UX 검증용 임시 메뉴가 운영 UI에 남아 실제 액션 목록 가독성을 저해함.
- **결정**:
  - 모바일 선택 액션 BottomSheet에서 `임시 항목` 메뉴를 제거한다.
- **이유**:
  - 검증 단계가 끝난 임시 데이터는 운영 화면에서 제거해 사용자 혼선을 줄인다.

### BottomSheet 터치 드래그 passive 경고 대응 (2026-02-17)
- **문제**:
  - 모바일 BottomSheet 드래그 중 `onTouchMove`에서 `preventDefault()`가 passive 이벤트 경로와 충돌하며 브라우저 경고가 발생함.
  - 본문 스크롤이 있는 상태에서 아래로 당길 때, 스크롤과 시트 드래그가 자연스럽게 이어지지 않음.
- **결정**:
  - `onTouchMove`에서는 `preventDefault()`를 호출하지 않는다.
  - 터치 시작 지점이 본문인 경우, 아래 방향 제스처에서 `scrollTop > 0`이면 시트 드래그를 보류하고 본문 스크롤을 우선 소모한다.
  - `scrollTop === 0`에 도달한 시점부터 시트 하강 드래그를 적용한다.
  - 패널에 native touch listener를 직접 등록하고 `touchmove`를 `passive:false`로 처리한다.
  - pointer 이벤트는 `pointerType === "touch"`를 무시해 터치 경로와 중복 처리되지 않게 분리한다.
  - `if (!shouldRender) return null` 조기 반환은 모든 Hook 선언 이후로 이동해 Hook 호출 순서를 고정한다.
  - 본문 터치 제스처는 기본적으로 네이티브 스크롤을 우선하며, `scrollTop === 0`에서 아래 방향 드래그일 때만 시트 드래그로 전환한다.
  - 전환 시 끊김 완화를 위해 드래그/높이/임계값을 `ref`로 추적하고 touch listener effect 의존성을 `shouldRender`로 축소한다.
  - 전환 지연을 줄이기 위해 `fromContentScroll` 상태와 `lastTouchY`를 추적해 top 도달 첫 프레임의 이동량을 즉시 시트 드래그 시작점에 반영한다.
  - 시트 드래그 렌더링은 `height` 변경 대신 `transform(translateY)` 오프셋 기반으로 전환한다.
- **이유**:
  - React 터치 이벤트 리스너가 passive로 동작하는 경로에서 `preventDefault()`는 무시되고 경고만 유발할 수 있다.
  - 드래그 높이 계산은 기존 로직으로 유지하면서 경고 원인 호출만 제거하는 것이 가장 안전하다.
  - 모바일 표준 BottomSheet UX(내용 스크롤 top 도달 후 시트 드래그 전환)에 맞춘 상호작용을 제공할 수 있다.
  - 추가로 드래그 이동량을 스크롤 감소에 먼저 소비해, 한 번의 제스처 내에서 `스크롤 소모 -> 시트 하강`이 연속적으로 이어지도록 보강한다.

### BottomSheet 하강 후 상향 복귀 드래그 보정 (2026-02-18)
- **문제**:
  - 본문에서 시작한 터치 제스처로 시트를 아래로 내린 뒤 위로 올릴 때, `gestureMode`가 너무 이르게 `scroll`로 복귀되어 시트가 다시 올라오지 않는 현상이 발생.
- **결정**:
  - `gestureMode === "drag"` 상태에서 위 방향 이동(`deltaY <= 0`)이 들어와도, 현재 `dragOffset > 0`이면 `scroll`로 전환하지 않고 drag를 유지한다.
  - `dragOffset <= 0`일 때만 `scroll`로 전환해 본문 스크롤 우선 동작을 유지한다.
- **이유**:
  - 콘텐츠 시작 제스처에서도 시트가 이미 내려간 상태라면 상향 이동은 시트 복귀 의도일 가능성이 높다.
  - 스크롤 우선 정책은 유지하면서도, 하강 후 복귀 불가 UX 결함을 최소 변경으로 해결할 수 있다.

### Space 절대경로 비노출 구조 1차 전환 (2026-02-17)
- **문제**:
  - 권한이 없는 Space 노출 및 일부 UI에서 절대경로가 노출될 수 있어 보안/정보노출 리스크가 있었음.
  - 탐색기 경로 처리 로직이 절대경로 문자열 조작에 의존해 노출 차단이 어려웠음.
- **결정**:
  - `GET /api/spaces` 응답에서 `space_path`를 제거한다.
  - `GET /api/spaces/{id}/browse`의 `path`를 절대경로가 아닌 Space 상대경로로 반환한다.
  - 프론트 탐색기 상태(`selectedPath`)를 Space 상대경로 기준으로 사용하도록 전환한다.
  - 트리/브레드크럼/파일 작업 API 호출은 `spaceId + relativePath` 조합만 사용한다.
- **이유**:
  - 절대경로를 클라이언트로 전달하지 않으면 노출면적을 구조적으로 줄일 수 있다.
  - 상대경로 중심 모델이 RBAC Space 경계와 더 잘 맞고, 이후 보안 점검/유지보수가 단순해진다.

### RBAC 운영 하드닝 및 즉시 반영 정책 (2026-02-17)
- **문제**:
  - Role 삭제 시 할당 사용자 유무 검증이 없으면 사용자 레코드의 role 값이 고아 상태가 될 수 있음.
  - 시스템 Role 권한을 전부 제거하면 관리 기능 접근 불능 등 운영 리스크가 발생할 수 있음.
  - 현재 로그인 사용자의 Role 권한을 변경해도 프론트 권한 상태 반영이 지연될 수 있음.
- **결정**:
  - 사용 중 Role 삭제를 차단한다(해당 Role 사용자 수 > 0이면 삭제 거부).
  - 시스템 Role은 권한 전체 제거를 차단한다(최소 1개 권한 유지).
  - 권한 관리 저장 시 대상 Role이 현재 로그인 사용자 Role이면 `refreshSession()`을 즉시 실행한다.
  - 테스트로 위 정책을 회귀 검증한다.
- **이유**:
  - 운영 중 권한 정책 변경으로 인한 계정/접근 불일치 리스크를 줄일 수 있다.
  - 권한 변경 직후 UI/세션 상태를 일치시켜 혼란을 최소화할 수 있다.

### 편집형 RBAC(역할/권한 관리) 도입 (2026-02-17)
- **문제**:
  - 기존 권한 구조는 코드 하드코딩 매핑이라 역할 추가/삭제 및 권한 조정을 런타임에서 수행할 수 없었음.
  - `users.role`의 DB CHECK 제약(`admin|user`)으로 커스텀 역할 확장이 불가능했음.
- **결정**:
  - 권한 모델을 DB 중심으로 전환:
    - `roles`, `permissions`, `role_permissions` 테이블 도입
    - 기본 역할(admin/user)과 기본 권한 키를 시드
  - 기존 DB 대상 마이그레이션에서 `users.role` CHECK 제약을 제거(데이터 보존 방식으로 재생성).
  - 역할 관리 API(`/api/roles`, `/api/permissions`)를 추가하고, 인증 미들웨어는 역할별 권한을 DB에서 조회해 판정.
  - 프론트 `권한 관리` 화면을 조회형에서 편집형(역할 생성/삭제/권한 저장)으로 전환.
- **이유**:
  - 운영자가 재배포 없이 역할/권한 정책을 조정할 수 있어 관리 유연성이 높아진다.
  - 서버 권한 판정과 UI 노출 기준이 동일한 데이터 소스(DB)에 기반해 일관성을 유지할 수 있다.

### 권한 2차: Space/File 리소스 권한 체크 연동 (2026-02-17)
- **문제**:
  - 1차 권한 적용 이후에도 Space/File API는 경로별 권한 키만 확인하고, 특정 Space 리소스 접근 가능 여부는 미들웨어 레벨에서 일관 확인되지 않았음.
  - 프론트에서 `file.write` 없는 사용자에게도 일부 쓰기 액션 UI가 노출될 수 있었음.
- **결정**:
  - 인증 미들웨어에 Space ID 추출 로직을 추가하고, `CanAccessSpaceByID(username, spaceID, required)`를 연동한다.
  - `/api/spaces/{id}/files/download*`는 `read`, 나머지 파일 작업은 `write`로 리소스 권한을 구분한다.
  - 권한 키에 `space.write`를 추가하고, 관리자에게만 부여한다.
  - 프론트 탐색기에서 `file.write` 미보유 시 업로드/이동/복사/이름변경/삭제 및 DnD 쓰기 동작을 비활성화한다.
- **이유**:
  - 전역 권한(RBAC)과 리소스 범위 체크를 결합해 실제 데이터 접근 제어를 강화할 수 있다.
  - UI 노출과 서버 차단 기준을 맞춰 사용자 혼란(누르면 실패)을 줄일 수 있다.

### 권한 키 기반 접근 제어 1차 전환 (2026-02-17)
- **문제**:
  - 인증 미들웨어가 `adminOnlyPath` 하드코딩 중심이라, 권한 모델 확장 시 경로별 예외 관리 비용이 커질 수 있었음.
  - 프론트는 로그인 사용자 권한 목록을 알 수 없어 설정 화면 노출 제어가 역할 문자열에 의존할 수밖에 없었음.
- **결정**:
  - 백엔드 인증 미들웨어를 `requiredPermissionForRequest(method, path)` 기반으로 전환한다.
  - 1차 범위 권한 키를 `account.read`, `account.write`, `server.config.read`, `server.config.write`로 적용한다.
  - FTP 관련 관리는 별도 `ftp.manage`를 만들지 않고 `server.config.*`로 통합한다.
  - `/api/auth/login`, `/api/auth/refresh`, `/api/auth/me` 응답에 `permissions` 배열을 포함한다.
  - 프론트 Settings 메뉴는 권한 키 유무로 `서버`, `계정 관리` 섹션 노출을 제어한다.
- **이유**:
  - 경로 하드코딩보다 권한 키 매핑이 이후 권한 세분화/확장에 유리하다.
  - 프론트 노출 제어와 백엔드 실제 차단 기준을 동일한 권한 키로 맞춰 일관성을 확보할 수 있다.

### 인증 401 전역 처리 및 하드닝 (2026-02-16)
- **문제**:
  - 인증 만료 시 일부 화면에서 API만 401 실패하고 로그인 화면으로 복귀하지 않는 경로가 존재했음.
  - JWT 시크릿이 개발 기본값으로도 동작해 프로덕션 안전성이 충분하지 않았음.
- **결정**:
  - 프론트 공통 `apiFetch` 레이어를 도입하고 모든 API 요청을 단일 경로로 통합한다.
  - 401 응답 시 `refresh` 재시도 후 실패하면 `/login`으로 리다이렉트한다.
  - 프로덕션에서 `COHESION_JWT_SECRET` 미설정/약한 값(32자 미만)을 서버 시작 단계에서 차단한다.
  - 쿠키 `Secure` 판단에 `X-Forwarded-Proto=https`를 반영한다.
- **이유**:
  - 인증 실패 처리의 일관성을 확보해 UX/보안을 동시에 안정화할 수 있다.
  - 운영 환경에서 기본/약한 시크릿 사용을 방지해 토큰 위변조 위험을 낮출 수 있다.
  - 리버스 프록시 HTTPS 환경에서 쿠키 보안 속성 누락을 방지할 수 있다.

### Settings 내 프로필/로그아웃 섹션 도입 (2026-02-16)
- **문제**:
  - 로그인 도입 이후에도 설정 화면에서 현재 계정 정보 확인 및 로그아웃 진입점이 분리되어 있었음.
- **결정**:
  - Settings 메뉴에 `내 프로필` 섹션을 추가하고, 현재 사용자 정보와 로그아웃 액션을 한 화면에 제공한다.
  - `AuthProvider`의 세션 갱신/로그아웃 함수를 재사용해 별도 상태 중복을 만들지 않는다.
- **이유**:
  - 계정 관련 핵심 액션(확인/세션 정리)을 설정 내에서 즉시 처리할 수 있어 UX 흐름이 단순해진다.
  - 인증 상태의 단일 소스(`AuthContext`)를 유지해 동기화 비용을 줄일 수 있다.

### JWT 로그인 1차 도입 (2026-02-16)
- **문제**:
  - 계정/권한 모델이 도입되었지만 웹 UI에는 로그인 세션 개념이 없어 API 접근 제어가 불가능했음.
- **결정**:
  - 서버 세션 대신 JWT 기반 인증을 도입한다.
  - 토큰 전달은 브라우저 저장소가 아닌 HttpOnly 쿠키를 사용한다.
  - 토큰 전략은 `access(15분)` + `refresh(7일)`로 분리한다.
  - `/api/*`에 인증 미들웨어를 적용하고, 계정/설정/재시작 API는 관리자 권한으로 제한한다.
  - 프론트는 `AuthProvider`에서 `me -> refresh -> me` 순서로 세션 복구를 수행하고, 라우트 가드로 접근을 통제한다.
- **이유**:
  - JWT는 무상태 인증으로 서버 구조와 잘 맞고, HTTP API/FTP 계정 정책과 역할 기반 권한을 일관되게 확장할 수 있다.
  - HttpOnly 쿠키는 XSS에 의한 토큰 탈취 위험을 줄일 수 있어 로컬스토리지 저장보다 안전하다.

### Settings 계정관리 섹션 도입 (2026-02-16)
- **문제**:
  - 백엔드 계정/권한 API가 준비되어 있지만, 설정 화면에서 계정을 관리할 UI 진입점이 없었음.
- **결정**:
  - Settings 좌측 메뉴에 `계정 관리` 섹션을 추가한다.
  - 프론트에 `accounts` API 모듈을 신설하고, `GET/POST/PATCH/DELETE /api/accounts`를 직접 연동한다.
  - 1차 UI 범위는 계정 CRUD(목록/생성/수정/삭제)로 한정하고, Space별 권한 편집은 후속 단계로 분리한다.
- **이유**:
  - 운영자가 계정 생명주기를 설정 화면 안에서 즉시 처리할 수 있어 실제 운영 동선이 완성된다.
  - 권한 편집까지 한 번에 확장하면 스코프가 커지므로, 우선 계정 기본 관리 기능을 안정적으로 제공하는 것이 효율적이다.

### Main/Settings 레이아웃 및 Settings 섹션 공통 컴포넌트화 (2026-02-15)
- **문제**:
  - 메인과 설정 화면의 헤더/사이드 구조가 유사함에도 클래스/마크업이 분산되어 유지보수 비용이 큼.
  - Settings 섹션 내 제목/설명/좌우 정렬 row 패턴이 반복되어 수정 누락 가능성이 존재.
- **결정**:
  - 전역 `layout-*` 클래스로 페이지/헤더/사이드/본문 골격을 공통화한다.
  - 공통 헤더 컴포넌트(`HeaderBrand`, `HeaderGroup`)를 추가해 헤더 내부 구조를 통일한다.
  - Settings 전용 공통 컴포넌트(`SettingSectionHeader`, `SettingRow`)를 추가해 반복 UI 패턴을 치환한다.
- **이유**:
  - 구조적 반복을 줄여 이후 UI 밀도/간격 조정 시 변경 지점을 최소화할 수 있다.
  - 메인/설정의 레이아웃 일관성을 높이면서 기능 로직 변경 없이 리팩토링할 수 있다.

### Grid 가로 여백 채움 레이아웃 적용 (2026-02-15)
- **문제**:
  - 데스크톱 Grid에서 아이템 배열 뒤쪽으로 빈 가로 여백이 남아 시각적으로 느슨해 보임.
- **결정**:
  - 컬럼 정의를 `repeat(auto-fill, minmax(172px, 1fr))`로 전환해 남는 영역을 카드 폭으로 분배한다.
- **이유**:
  - 동일한 카드 밀도를 유지하면서도 화면 폭을 더 균일하게 활용할 수 있다.

### 파일 목록 스크롤바 경량 스타일 적용 (2026-02-15)
- **문제**:
  - 커스텀 오버레이 기반 페이드 스크롤 인디케이터가 대용량 목록(이미지 다수 로딩)에서 시각적으로 불안정해 보일 수 있음.
  - 스크롤 스타일을 개선하면서도 스크롤 위치 안정성은 유지해야 함.
- **결정**:
  - 커스텀 스크롤 인디케이터 로직을 제거하고 네이티브 스크롤로 복원한다.
  - 전역 스크롤바를 얇은 형태(6px)와 낮은 대비 thumb로 경량 스타일링한다.
  - 정렬 Select는 고정폭 대신 `fit-content`로 전환해 옵션 길이에 맞춘다.
- **이유**:
  - 네이티브 스크롤은 플랫폼별 안정성이 가장 높고 예측 가능성이 좋다.
  - 최소 스타일만 적용하면 시각적 부담은 줄이면서 동작 리스크를 최소화할 수 있다.

### PC 모달 오픈 중 배경 선택 변경 차단 (2026-02-15)
- **문제**:
  - PC에서 선택 상태로 모달을 띄운 뒤 배경 영역을 클릭하면 선택 집합이 변경되는 현상 발생.
  - 모달 마스크를 보강해도 일부 케이스에서 전역 이벤트 경로를 통해 선택 상태가 흔들림.
- **결정**:
  - 모달 오픈 상태에서는 Grid 박스선택 훅(`useBoxSelection`)을 비활성화한다.
  - `useBoxSelection`의 `window.mousedown` 시작점에서 모달 레이어 타깃 및 오픈 마스크 존재 여부를 검사해 즉시 차단한다.
- **이유**:
  - 문제의 근본 경로가 카드 클릭이 아닌 전역 박스선택 시작 이벤트였기 때문에, 모달 상태와 박스선택 경로를 명시적으로 분리해야 재발을 막을 수 있다.

### 이동 아이콘 PC/모바일 일원화 (2026-02-15)
- **문제**:
  - 동일한 이동 액션이 모바일과 PC에서 서로 다른 아이콘(폴더+화살표 vs 가위)으로 표시되어 의미 인지가 분산됨.
- **결정**:
  - PC 선택바 이동 아이콘을 모바일과 동일한 Material Symbols `drive_file_move`로 통일한다.
- **이유**:
  - 플랫폼 간 아이콘 의미를 일관화해 학습 비용과 오인 가능성을 줄일 수 있다.

### 모바일 선택모드 상단 헤더 전환 (2026-02-15)
- **문제**:
  - 선택모드 상태/액션이 하단에 집중되면 사용자가 현재 모드 인지를 위해 시선을 반복 이동해야 함.
- **결정**:
  - 모바일 선택모드에서는 `FolderContentToolbar`를 선택 전용 헤더로 대체한다.
  - 기본 액션(이동/복사/다운로드)은 상단 헤더에, 보조 액션(이름 변경/삭제)은 `:` 액션시트에 배치한다.
- **이유**:
  - 선택모드 상태를 상단에서 즉시 인지할 수 있고, 핵심 액션 접근 거리를 단축할 수 있다.

### 모바일 선택 툴바 단순화 및 하단 안전영역 보정 (2026-02-15)
- **문제**:
  - 상단 툴바 + 하단 액션시트(`:`) 조합은 모바일에서 액션 경로가 분산되고 조작 단계가 길어짐.
  - 하단 고정 UI는 기기별 safe-area에 따라 버튼 일부가 잘릴 수 있음.
- **결정**:
  - 모바일 선택 툴바를 하단 배치로 복원하고 `safe-area-inset-bottom`을 적용한다.
  - `:` 버튼/액션시트는 제거하고, `복사`/`다운로드`를 툴바 직접 액션으로 승격한다.
  - `삭제` 버튼은 우측 끝으로 분리 배치한다.
- **이유**:
  - 선택 후 핵심 액션 접근 단계를 줄여 조작 시간을 단축할 수 있다.
  - 위험 액션을 분리해 오탭 리스크를 줄이고, 기기별 하단 UI 잘림을 예방할 수 있다.

### 모바일 선택 툴바 상단 배치 및 린트 안정화 (2026-02-15)
- **문제**:
  - 모바일 선택 툴바가 하단 고정이라 작업 맥락(현재 목록 상단 영역) 대비 시선 이동이 큼.
  - `FolderContent`/일부 훅에서 effect 내부 동기 `setState` 및 dependency 누락으로 lint가 실패함.
- **결정**:
  - 모바일 선택 툴바/실드를 상단 고정으로 이동한다.
  - effect 내부 직접 상태 갱신 패턴을 정리하고 hook dependency를 명시적으로 보정한다.
  - `FolderContent` 리팩토링 Phase 4 검증 기준을 `lint/build/go test` 통과로 확정한다.
- **이유**:
  - 모바일 선택 액션의 가시성과 접근성을 높이고, 콘텐츠와의 상호작용 흐름을 단순화할 수 있다.
  - 린트 실패를 해소해 이후 기능 개발 시 회귀 탐지 신뢰도를 유지할 수 있다.

### 트리 확장 아이콘을 폴더 상태 아이콘으로 전환 (2026-02-15)
- **문제**:
  - 트리 노드에서 화살표 + 폴더 아이콘이 동시에 보여 수평 공간을 더 사용하고 시각 요소가 중복됨.
- **결정**:
  - `FolderTree`의 `switcherIcon`을 커스텀하여 화살표 대신 닫힘/열림 폴더 아이콘으로 상태를 표시한다.
  - 기본 `showIcon`/`icon` 방식은 제거해 아이콘 중복을 방지한다.
  - 아이콘 세트는 가독성과 인지도 기준으로 Material Symbols Rounded(`folder`, `folder_open`)를 채택한다.
- **이유**:
  - 확장 상태 전달과 폴더 의미 전달을 단일 아이콘으로 통합해 공간 효율과 인지 효율을 동시에 개선할 수 있다.

### 헤더/툴바 아이콘 버튼 텍스트 제거 (2026-02-15)
- **문제**:
  - 업로드/설정 버튼이 아이콘과 텍스트를 함께 표시해 상단 UI 밀도가 높고 모바일/소형 화면에서 시각적 노이즈가 큼.
- **결정**:
  - `FolderContentToolbar` 업로드 버튼과 `MainLayout` 설정 버튼을 아이콘 전용 버튼으로 전환한다.
  - 접근성은 `aria-label`과 `title` 속성으로 유지한다.
- **이유**:
  - 주요 액션은 아이콘만으로도 식별 가능해 공간 효율과 일관성을 높일 수 있다.
  - 접근성 메타데이터를 유지해 보조기기/툴팁 경험 저하를 방지한다.

### PC Grid 박스선택 실시간 교차 모드 전환 (2026-02-14, #60)
- **문제**:
  - 기존 박스선택이 드래그 중 한 번이라도 교차한 항목을 누적하는 방식이라 Finder/Explorer 기본 UX와 다름.
  - 스크롤 중 선택이 축소되어야 할 상황에서도 누적 유지되어 사용자가 기대하는 실시간 증감과 어긋남.
- **결정**:
  - `useBoxSelection` 선택 계산을 누적(`accumulated`) 기반에서 `현재 박스 교차 집합` 기반으로 전환한다.
  - Ctrl/Cmd는 초기 선택 대비 현재 교차 집합 토글, Shift는 초기 선택 + 현재 교차 집합 추가 규칙으로 유지한다.
- **이유**:
  - PC 파일 탐색기(Finder/Explorer)와 유사한 실시간 교차 선택 UX를 제공할 수 있다.
  - 드래그 중 휠/스크롤 상황에서도 선택 집합 증감이 직관적으로 동작한다.

### 모바일 내부 드래그 이동 비활성화 (2026-02-14)
- **문제**:
  - 모바일에서 롱프레스 기반 선택 UX와 내부 드래그 이동 UX가 동시에 존재하면 제스처 충돌 가능성이 높음.
  - 폴더/파일 끌어 이동은 데스크톱 중심 상호작용이라 모바일 사용성 이점이 낮음.
- **결정**:
  - 모바일(`sm` 미만)에서는 Grid/Table 내부 드래그 이동을 비활성화한다.
  - 데스크톱에서는 기존 드래그 이동 기능을 유지한다.
- **이유**:
  - 모바일 제스처를 `탭=열기`, `롱프레스=선택`으로 단순화해 오동작/혼란을 줄일 수 있다.
  - 핵심 모바일 작업 흐름(탐색/선택/액션시트)을 안정적으로 유지할 수 있다.

### 모바일 롱프레스 기반 선택모드 전환 (2026-02-14)
- **문제**:
  - 모바일에서 폴더 단일 탭을 즉시 진입으로 바꾸면서, 폴더를 포함한 멀티 선택 진입 경로가 사라짐.
  - 탭 동작 하나로 `열기`와 `선택`을 동시에 만족시키기 어려움.
- **결정**:
  - 모바일(`sm` 미만)에서는 롱프레스로 선택모드에 진입하고, 롱프레스 대상 항목을 첫 선택으로 설정한다.
  - 선택모드에서는 탭 동작을 멀티 선택/해제로 전환해 폴더/파일 모두 일괄 작업 대상으로 다룬다.
  - 선택모드 외 기본 상태에서는 폴더 단일 탭 즉시 진입을 유지한다.
  - Table 뷰는 모바일 선택모드가 아닐 때 체크박스를 숨겨 선택 진입 경로를 롱프레스로 통일한다.
- **이유**:
  - 모바일 사용자가 `탭=열기`, `롱프레스=선택`이라는 익숙한 제스처 모델로 학습 비용 없이 사용할 수 있다.
  - 폴더 탐색 속도(단일 탭 진입)와 멀티 선택 확장성(롱프레스 선택모드)을 동시에 확보할 수 있다.

### 모바일 폴더 진입 제스처 보정 (2026-02-14)
- **문제**: 폴더 진입이 더블클릭(`onDoubleClick`) 중심이라 모바일 단일 탭에서 진입이 어려움.
- **결정**:
  - 모바일(`sm` 미만)에서는 폴더 단일 탭을 즉시 폴더 진입(`setPath`)으로 처리한다.
  - 데스크톱은 기존 선택/더블클릭 진입 흐름을 유지한다.
- **이유**:
  - 모바일 환경에서 더블탭 제스처 의존성을 줄이고 기본 탐색 흐름을 단순화할 수 있다.
  - 데스크톱의 다중 선택/더블클릭 UX와 충돌하지 않는다.

### 모바일 Grid 밀도 개선 + 테마 토글 진입점 단일화 (2026-02-14)
- **문제**:
  - 모바일 Grid(앨범) 뷰가 1열로 보이는 구간이 많아 화면 공간 활용이 비효율적임.
  - 헤더의 다크/라이트 토글과 `설정 > 외관`이 중복되어 테마 변경 진입점이 분산됨.
- **결정**:
  - `FolderContentGrid`에 breakpoint 분기를 추가해 모바일(`sm` 미만)에서는 기본 2열(`repeat(2, minmax(0, 1fr))`)로 렌더링한다.
  - 헤더 테마 토글을 제거하고 테마 변경은 `설정 > 외관`으로 일원화한다.
- **이유**:
  - 모바일에서 동일 화면 내 표시 밀도를 높여 탐색 효율을 개선할 수 있다.
  - 전역 헤더를 단순화하고 설정 변경 경로를 명확히 유지할 수 있다.

### Main 네비게이션 Drawer 도입 (2026-02-14, #55)
- **문제**: 고정 Sider 중심 구조로 모바일에서 화면 점유가 크고, 데스크톱에서도 오버레이 네비게이션이 필요할 수 있음.
- **결정**:
  - `MainLayout`에 `Drawer`를 도입하고 헤더에 `탐색기` 버튼으로 열 수 있도록 한다.
  - 반응형 기준은 `Grid.useBreakpoint`의 `lg`를 사용한다.
  - 모바일(`lg` 미만): Drawer 중심 네비게이션, 데스크톱: 기존 고정 Sider 유지 + Drawer 병행.
  - `MainSider`는 `containerType`(`sider` | `panel`)을 추가해 Sider/Drawer 공용 컴포넌트로 사용한다.
  - 모바일 Drawer에서는 경로 선택 후 자동 닫힘 처리한다.
  - 헤더 `탐색기` 버튼은 모바일에서만 노출한다(데스크톱에서는 고정 Sider가 기본 진입점).
- **이유**:
  - 모바일 사용성 개선과 데스크톱 유연성 확보를 동시에 달성할 수 있다.
  - 트리/스페이스 관련 기존 기능을 재사용해 구현 리스크를 최소화할 수 있다.

### Status 웹 접근 주소 다중 노출 복원 (2026-02-14)
- **문제**: 웹 접근 주소를 `window.location.origin` 단일값으로만 표시해 `vite server.host=true` 환경의 LAN 접근 주소가 보이지 않음.
- **결정**:
  - 상태 UI에서 `status.hosts`를 다시 사용해 다중 호스트 주소를 렌더링한다.
  - 포트는 백엔드 보고값이 아니라 현재 웹 포트(`window.location.port`, 기본 80/443 fallback)로 통일해 주소를 구성한다.
- **이유**:
  - 개발환경에서 로컬/LAN 접근 주소를 모두 확인할 수 있어 테스트 편의성이 높다.
  - 웹 접근 주소의 포트 기준은 프론트 런타임이 가장 정확하다.

### Status WEB 접근 포트 계산 책임 분리 (2026-02-14)
- **문제**: WEB 포트(`5173`)를 백엔드에서 고정 계산하면 Vite 포트 변경(`--port`)이나 실행 환경 차이를 반영하지 못함.
- **결정**:
  - 백엔드 `/api/status`에서 WEB 포트 하드코딩 계산 로직을 제거한다.
  - 상태 UI의 웹 접근 주소는 프론트 런타임(`window.location.origin`) 기준으로 표시한다.
  - WebDAV/API 포트는 계속 백엔드 설정 포트(`config.server.port`)를 사용한다.
- **이유**:
  - 웹 접근 주소 판단 책임은 현재 페이지를 서빙하는 프론트 런타임에 두는 것이 정확하다.
  - 백엔드와 프론트의 역할 경계를 명확히 유지하며 포트 변경 내성을 확보할 수 있다.

### Status 팝오버의 HTTP 경로 표기 정정 (2026-02-14)
- **문제**: 서버 상태 팝오버에서 HTTP 항목이 `:3000/api/`로 표시되어, 실제 웹 접근 주소 정보와 혼동을 유발.
- **결정**:
  - `/api/status`의 HTTP 프로토콜 경로를 `/`로 반환한다.
  - 프론트 팝오버의 HTTP 라벨을 `WEB`으로 표기하고, 접근 주소는 `http://{host}/`로 표시한다.
- **이유**:
  - 상태 패널의 목적을 API 엔드포인트 안내보다 실제 웹 접근 안내에 맞춘다.
  - 개발/프로덕션 모두에서 사용자가 접근 가능한 URL을 직관적으로 확인할 수 있다.

### Table 뷰 스크롤 컨테이너 분리 (2026-02-13)
- **문제**: FolderContent의 Table 뷰에서 세로 스크롤이 생성되지 않아 하단 파일 목록 접근이 어려움.
- **결정**:
  - `FolderContent` 루트에 `minHeight: 0`을 적용한다.
  - Table 뷰를 별도 래퍼(`flex:1`, `overflowY:auto`)로 감싸 스크롤 축을 명시적으로 분리한다.
- **이유**:
  - Grid 뷰와 동일한 스크롤 전략으로 일관성 확보.
  - 부모/자식 flex 레이아웃에서 높이 계산 이슈로 인한 스크롤 누락 방지.

### Space 생성 모달 입력 상태 분리 + 설명 저장 연동 (2026-02-13)
- **문제**:
  - Space 생성 모달의 이름/설명 입력이 전역 `spaceStore.isLoading`에 묶여 비활성화될 수 있음.
  - 모달의 설명 입력값(`spaceDesc`)이 실제 Space 생성 요청에 포함되지 않아 저장되지 않음.
- **결정**:
  - 모달 입력 비활성 기준을 전역 로딩 상태에서 로컬 제출 상태(`isCreating`)로 분리한다.
  - `spaceStore.createSpace`에 `description` 파라미터를 추가하고, 요청 payload에 `space_desc`를 포함한다(비어있으면 제외).
- **이유**:
  - 전역 상태 결합을 줄여 모달 입력 UX를 안정화.
  - 사용자가 입력한 설명이 실제 데이터로 저장되도록 일관성 확보.

### 싱글/멀티 다운로드 분기 정책 (2026-02-13)
- **문제**: 상단 선택바의 다운로드 액션이 선택 개수와 무관하게 `download-multiple`를 호출해 단일 파일도 ZIP으로 내려갈 수 있었음.
- **결정**:
  - 단일 선택(1개)은 단일 다운로드 API(`/files/download`)를 사용한다.
  - 다중 선택(2개 이상)만 멀티 다운로드 API(`/files/download-multiple`)로 ZIP을 생성한다.
  - 백엔드 `download-multiple`에도 1개 요청 보호 분기를 둬 단일 파일은 ZIP 없이 스트리밍한다.
- **이유**:
  - 사용자 기대와 일치: 파일 1개 다운로드 시 즉시 원본 파일을 받는 것이 자연스러움.
  - 하위 호환성: 기존 멀티 선택 ZIP 다운로드 UX는 유지.
  - 안정성: 프론트 분기 누락 시에도 백엔드가 의도치 않은 ZIP 생성을 방지.

### antd 정적 message 사용 제거 (2026-02-13)
- **문제**: `message` 정적 API 사용 시 동적 테마 컨텍스트를 소비하지 못해 경고 발생.
- **결정**: 정적 `message`/`Modal.confirm` 호출 대신 `App.useApp()`에서 제공되는 `message`/`modal` 인스턴스를 사용.
- **구현**:
  - `/settings` 라우트의 `ConfigProvider` 하위에 `App` 프로바이더 추가.
  - `AdvancedSettings`, `ServerSettings`, `DirectorySetupModal`, `DestinationPickerModal`, `useDragAndDrop`를 컨텍스트 기반 API로 전환.
- **이유**:
  - Ant Design 권장 패턴과 일치.
  - 테마/컨텍스트 반영 가능한 일관된 메시지 렌더링 확보.
  - 콘솔 경고 제거로 디버깅 신뢰도 개선.

### Folder Explorer Grid 자동 컬럼 배치 + 가로 스크롤 억제 (2026-02-13)
- **결정**: Grid 뷰를 브레이크포인트 고정 컬럼이 아닌 `auto-fit + minmax` 기반 자동 컬럼 배치로 전환하고, 가로 스크롤 억제를 위해 스크롤 축을 분리한다.
- **이유**:
  - 해상도별 고정 단계(예: 6/4/2)보다 연속적인 폭 적응이 가능해 공간 활용이 더 좋음.
  - 카드 최소 폭을 유지하면서 가능한 한 많은 항목을 한 줄에 표시할 수 있음.
  - 가로 스크롤의 주 원인(중첩 overflow, toolbar/selection bar 비랩핑) 제거.
- **구현**:
  - `FolderContentGrid`: CSS Grid `gridTemplateColumns: repeat(auto-fit, minmax(180px, 1fr))` 적용.
  - `FileExplorer`: 외곽 `overflow: hidden`.
  - `FolderContent` Grid 컨테이너: `overflowY: auto`, `overflowX: hidden`, `minWidth: 0`.
  - `FolderContentToolbar`, `FolderContentSelectionBar`: `flexWrap` 및 `AntSpace wrap` 적용.
  - 썸네일 표시: `ImageThumbnail`을 `object-fit: cover` 중심으로 변경하고 프리뷰 박스(`128px`)에 밀착되게 렌더링.
  - 밀도 조정: Grid `gap`을 16px → 12px, 카드 body padding을 16px → 12px으로 축소.

### 트리 targeted invalidation 적용 (2026-02-13, #35)
- **문제**: 파일 작업 후 트리를 전역 invalidate하여 불필요한 노드 재초기화/재로딩이 발생.
- **결정**: invalidate payload에 영향 경로를 포함하고, 트리는 해당 노드만 부분 무효화.
- **구현**:
  - `browseStore`: `treeInvalidationTargets` 추가, `invalidateTree(targets?)`로 확장.
  - `useFileOperations`: 액션별 영향 경로 계산.
    - 이름변경/삭제: 소스 부모 경로.
    - 폴더생성/업로드: 대상(부모) 경로.
    - 이동: 소스 부모 + 대상 경로.
    - 복사: 대상 경로.
  - `FolderTree`: target key 해석 후 해당 노드 children/loadedKeys만 초기화하고 필요 시 재로딩.
- **이유**:
  - 영향 없는 트리를 유지해 UX 안정성 개선.
  - 모달 트리와 사이드바 트리의 갱신 정책 일관성 확보.
  - 기존 전역 리프레시 API와의 하위 호환 유지(`targets` 미전달 시 legacy fallback).

### Serena MCP 필수 사용 (2026-02-04)
- **결정**: 모든 코드 탐색 및 수정 작업에서 Serena MCP 툴을 필수로 사용.
- **이유**:
  - 토큰 효율성: 파일 전체가 아닌 필요한 심볼만 읽어 토큰 절약.
  - 정확성: 심볼 단위 수정으로 실수 방지.
  - 일관성: 모든 AI 모델이 동일한 방식으로 코드 작업.
- **금지**: `Read`/`Edit` 툴로 코드 파일 읽기/수정.
- **필수**: `get_symbols_overview` → `find_symbol` → `replace_symbol_body` 워크플로우.
- **문서화**: `CLAUDE.md`에 상세 가이드 추가.

### Playwright MCP 브라우저 테스트 필수화 (2026-02-04)
- **결정**: UI 수정 시 Playwright MCP로 브라우저 직접 테스트 필수.
- **이유**: 스크린샷으로 UI 직접 확인하여 디자인 적합성 판단.
- **절차**: 수정 → 테스트 → 스크린샷 → 브라우저 종료.
- **로그 위치**: `.playwright-mcp/` (gitignore 처리됨).

### 실행 환경 문서화 (2026-02-04)
- **결정**: AI 에이전트를 위한 실행 환경 정보를 별도 문서로 분리.
- **이유**:
  - 서버 실행, 빌드, 포트 등 실행 관련 정보가 분산되어 있음.
  - AI가 매번 프로젝트 구조를 탐색하는 비효율 방지.
  - 환경 설정 변경 시 한 곳만 수정하면 됨.
- **구현**:
  - `docs/AGENTS.md` 생성: 프로젝트 구조, 서버 실행, 빌드, 포트, 테스트 등 통합.
  - CLAUDE.md, GEMINI.md에 AGENTS.md 읽기 지시 추가.

### Space 상대 경로 Breadcrumb (2026-02-04)
- **결정**: Space 선택 시 Breadcrumb을 절대 경로 대신 Space 기준 상대 경로로 표시.
- **이유**:
  - 사용자가 Space 내에서의 위치를 직관적으로 파악 가능.
  - 긴 절대 경로(/Users/...) 대신 간결한 경로 표시로 UX 개선.
  - Space 중심 워크플로우 강화.
- **구현**:
  - FolderTree의 onSelect 콜백에 Space 정보 추가.
  - MainLayout에서 selectedSpace state 관리.
  - FolderContent에서 Space 경로를 기준으로 상대 경로 계산.
  - 예: `/Users/twlee/Downloads/folder1` → `Downloads / folder1`
- **수정 파일**: FolderTree.tsx, MainLayout/index.tsx, MainSider.tsx, FileExplorer.tsx, FolderContent.tsx

### 문서 구조 통합 (2026-02-04)
- **결정**: `docs/master_rule.md`를 모든 규칙의 단일 소스로 통합.
- **이유**:
  - 규칙 분산(CLAUDE.md, GEMINI.md, master_rule.md)으로 인한 혼란 방지.
  - AI 모델 간 일관성 확보: 모든 모델이 동일한 규칙 참조.
  - 유지보수 단순화: 한 곳만 수정하면 됨.
- **변경 사항**:
  - `GEMINI.md`: "master_rule.md를 먼저 읽기"만 남김.
  - `CLAUDE.md`: `.claude/CLAUDE.md`로 이동 (Claude Code CLI 전용).
  - `master_rule.md`: Serena MCP, Playwright, 디자인, 커밋 규칙 모두 포함.

### Space 삭제 기능 Context Menu 구현 (2026-02-04)
- **결정**: Space 노드에 Context Menu 방식의 삭제 기능 구현.
- **이유**:
  - 직관적인 UX: 우클릭 대신 "..." 버튼 클릭으로 메뉴 표시.
  - 일관성: Ant Design Tree와 Dropdown 컴포넌트 활용.
  - 안전성: Modal.confirm으로 삭제 확인 절차 추가.
- **구현**:
  - FolderTree: `titleRender`로 Space 노드에만 Dropdown 추가.
  - MainSider: `useDeleteSpace` 훅으로 DELETE API 호출.
  - 삭제 후 `refetch()`로 트리 자동 갱신.
  - 성공/실패 시 message 컴포넌트로 사용자에게 피드백.
- **백엔드**: DELETE `/api/spaces/:id` 엔드포인트는 이미 구현되어 있었음.

### 파일 표시 버그 수정 (2026-02-04)
- **문제**: FolderContent에서 폴더만 표시되고 파일이 표시되지 않는 버그 발견.
- **원인 분석**:
  - `browse_handler.go`의 `handleBrowse` 함수에서 `ListDirectory(true, targetPath)` 호출.
  - `isOnlyDir=true` 파라미터로 인해 `browse/service.go`의 `ListDirectory` 함수가 파일을 필터링.
  - 92-94라인: `if isOnlyDir && !entry.IsDir() { continue }` 로직으로 파일 제외.
- **결정**: `isOnlyDir` 파라미터를 `false`로 변경하여 파일과 폴더 모두 반환.
- **이유**:
  - 파일 탐색기의 핵심 기능은 파일과 폴더를 모두 보여주는 것.
  - FolderContent는 이미 파일과 폴더를 구분하여 표시하는 UI가 구현되어 있음.
  - 왼쪽 FolderTree는 폴더만 표시하고, 오른쪽 FolderContent는 파일과 폴더 모두 표시하는 것이 직관적.
- **수정 파일**: `apps/backend/internal/browse/handler/browse_handler.go:51`
- **결과**: Space 선택 시 폴더와 파일이 모두 정상 표시됨.

### 파일 다운로드 기능 구현 (2026-02-04)
- **결정**: 파일 클릭 시 브라우저의 기본 다운로드 기능을 사용하여 파일을 다운로드.
- **이유**:
  - 단순하고 직관적인 UX: 파일 이름을 클릭하면 바로 다운로드.
  - 브라우저 내장 다운로드 관리 활용: 사용자가 익숙한 방식.
  - 폴더와 파일 동작 구분: 폴더는 클릭 시 이동, 파일은 클릭 시 다운로드.
- **구현**:
  - **백엔드**: `handleDownload` 함수 추가.
    - `/api/browse/download?path=<파일경로>` 엔드포인트.
    - `Content-Disposition: attachment` 헤더로 다운로드 강제.
    - 보안: 디렉토리 다운로드 방지, 파일 존재 여부 및 권한 검증.
    - `io.Copy`로 파일 스트리밍.
  - **프론트엔드**: FolderContent의 render 함수 수정.
    - 폴더: `<a onClick={...}>` (기존 동작 유지)
    - 파일: `<a href="/api/browse/download?path=..." download>`
    - 조건부 렌더링으로 폴더와 파일 구분.
- **대안 검토**:
  - fetch API로 다운로드: 복잡하고 추가 코드 필요, 브라우저 기본 기능보다 장점 없음.
  - 우클릭 메뉴로만 다운로드: 덜 직관적, 추가 클릭 필요.
- **수정 파일**:
  - `apps/backend/internal/browse/handler/browse_handler.go` (handleDownload, RegisterRoutes)
  - `apps/frontend/src/features/browse/components/FolderContent.tsx` (render 함수)
- **결과**: 파일 클릭 시 다운로드 정상 작동, README.md 테스트 완료.

### Space 경로 보안 강화 (2026-02-04)
- **문제**: Space로 할당되지 않은 시스템 경로에도 자유롭게 접근 가능한 보안 취약점.
- **요구사항**: Space 경로만 접근 허용하되, Space 생성 시 시스템 탐색은 가능해야 함.
- **결정**: 백엔드에서 경로 검증 수행, Space 생성 모드는 별도 플래그로 구분.
- **이유**:
  - 보안: 사용자가 의도적으로 할당한 Space 외부 경로는 접근 불가.
  - 유연성: Space 생성 시에는 시스템 전체를 탐색할 수 있어야 폴더 선택 가능.
  - 서버 측 검증: 클라이언트 우회 방지, 신뢰할 수 있는 검증.
- **구현**:
  - **백엔드**:
    - Handler에 spaceService 주입 (Space 목록 조회).
    - `isPathAllowed(path)`: 요청 경로가 Space의 하위 경로인지 확인.
      - Space 목록을 가져와서 각 space_path와 비교.
      - `strings.HasPrefix`로 하위 경로 판별.
      - Space가 없으면 모든 경로 허용 (하위 호환성).
    - `handleBrowse`, `handleDownload`에서 경로 검증 수행.
    - `system=true` 쿼리 파라미터로 시스템 탐색 모드 지원.
      - systemMode일 때는 경로 검증 스킵.
  - **프론트엔드**:
    - `useBrowseApi`: `fetchDirectoryContents(path, systemMode=false)` 파라미터 추가.
    - `FolderTree`: `showBaseDirectories`일 때 `systemMode=true` 전달.
- **대안 검토**:
  - 별도 API 엔드포인트 (`/api/browse/system`): 중복 코드, 유지보수 복잡도 증가.
  - 클라이언트 검증: 보안 취약, 우회 가능.
  - Space가 없을 때만 전체 허용: 현재 채택, 단순하고 효과적.
- **보안 고려사항**:
  - Space가 없으면 모든 경로 허용: 초기 사용자 경험 향상, 첫 Space 생성 전까지는 제한 없음.
  - 경로 정규화: `filepath.Clean`으로 `..` 등 우회 시도 방지.
  - 403 에러: 명확한 에러 메시지로 권한 부족 알림.
- **수정 파일**:
  - `apps/backend/internal/browse/handler/browse_handler.go` (isPathAllowed, 검증 로직)
  - `apps/backend/main.go` (spaceService 주입)
  - `apps/frontend/src/features/browse/hooks/useBrowseApi.ts` (systemMode 파라미터)
  - `apps/frontend/src/features/browse/components/FolderTree.tsx` (systemMode 전달)
- **결과**:
  - Space 경로만 접근 가능, 외부 경로는 403 에러.
  - Space 생성 모달에서 시스템 전체 탐색 정상 작동.

### 파일/폴더 우클릭 컨텍스트 메뉴 구현 (2026-02-05)
- **결정**: 파일과 폴더에 우클릭 컨텍스트 메뉴를 추가하고 상위 폴더 버튼 제거.
- **이유**:
  - 현대적인 파일 관리자 UX: 우클릭으로 다양한 작업 접근.
  - UI 단순화: Breadcrumb만으로 충분히 탐색 가능, 별도 버튼 불필요.
  - 파일/폴더 타입별 차별화: 파일과 폴더에 맞는 작업 제공.
- **구현**:
  - **컨텍스트 메뉴 구조**:
    - 파일: "다운로드", "이름 변경", "삭제"
    - 폴더: "이름 변경", "삭제" (다운로드 제외)
  - **상위 폴더 버튼 제거**: Breadcrumb의 상위 경로 클릭으로 대체.
  - **컨텍스트 메뉴 상태 관리**:
    - 마우스 위치(x, y)와 대상 레코드 저장.
    - 메뉴 외부 클릭 시 자동 닫힘 (useEffect + document.addEventListener).
  - **Table onRow 이벤트**: `onContextMenu` 핸들러로 우클릭 감지.
  - **Ant Design Menu**: position: fixed로 마우스 위치에 표시.
- **수정 파일**:
  - `apps/frontend/src/features/browse/components/FolderContent.tsx`
- **결과**: 상위 폴더 버튼 제거, 파일/폴더별 컨텍스트 메뉴 정상 작동.

### 파일/폴더 이름 변경 및 삭제 기능 구현 (2026-02-05)
- **결정**: 백엔드 API와 프론트엔드 모달로 이름 변경 및 삭제 기능 완전 구현.
- **이유**:
  - 파일 관리 기본 기능: 사용자가 파일/폴더를 직접 관리할 수 있어야 함.
  - 안전한 삭제: Modal.confirm으로 실수 방지.
  - 즉시 반영: 작업 후 목록 자동 새로고침으로 UX 향상.
- **구현**:
  - **백엔드 API**:
    - `POST /api/browse/rename`: 파일/폴더 이름 변경.
      - 요청: `{ oldPath, newName }`
      - 보안: 기존 경로와 새 경로 모두 Space 내부인지 검증.
      - `os.Rename` 사용.
    - `POST /api/browse/delete`: 파일/폴더 삭제.
      - 요청: `{ path }`
      - 보안: Space 내부 경로인지 검증.
      - 폴더는 `os.RemoveAll` (하위 파일 포함), 파일은 `os.Remove`.
  - **프론트엔드**:
    - **이름 변경 모달**:
      - 현재 이름을 기본값으로 표시.
      - Input에 Enter 키 입력 시 변경 실행.
      - 성공 시 `message.success`, 실패 시 `message.error`.
      - 작업 후 `fetchDirectoryContents`로 목록 새로고침.
    - **삭제 확인 모달**:
      - `Modal.confirm` 사용.
      - 폴더 삭제 시 "하위 파일 포함 삭제" 경고.
      - 확인 후 DELETE API 호출.
      - 성공 시 목록 자동 새로고침.
    - **컨텍스트 메뉴 onClick**:
      - "이름 변경": 모달 열기, 현재 이름을 state에 설정.
      - "삭제": 확인 모달 표시.
- **보안 고려사항**:
  - 이름 변경 시 새 경로도 Space 내부인지 검증: 경로 탈출 방지.
  - Space 외부 경로 접근 시 403 에러.
  - `filepath.Clean`으로 경로 정규화.
- **수정 파일**:
  - `apps/backend/internal/browse/handler/browse_handler.go` (handleRename, handleDelete)
  - `apps/frontend/src/features/browse/components/FolderContent.tsx` (모달, API 호출)
- **결과**: 이름 변경 및 삭제 모두 정상 작동, 목록 자동 새로고침 확인.

### 다운로드 우클릭 전용 변경 (2026-02-05)
- **결정**: 파일 이름 클릭 시 다운로드 제거, 우클릭 메뉴로만 다운로드 가능.
- **이유**:
  - 일관성: 모든 파일 작업을 우클릭 메뉴로 통일.
  - 실수 방지: 의도치 않은 다운로드 방지.
  - 폴더와 일관된 UX: 폴더는 클릭 시 이동, 파일은 클릭 무반응.
- **구현**:
  - 파일 이름을 `<a>` 태그에서 `<span>` 태그로 변경.
  - 다운로드는 컨텍스트 메뉴의 "다운로드" 항목으로만 가능.
  - 파일 아이콘과 이름은 시각적으로만 표시, 클릭 이벤트 없음.
- **대안 검토**:
  - 파일 클릭 시 미리보기: 아직 미리보기 기능 미구현, 추후 고려.
  - 더블 클릭으로 다운로드: 폴더 더블 클릭(이동)과 혼동 가능.
- **수정 파일**:
  - `apps/frontend/src/features/browse/components/FolderContent.tsx` (render 함수)
- **결과**: 파일 클릭 시 다운로드 안 됨, 우클릭 메뉴로만 다운로드 가능.

### 파일 업로드 기능 구현 (2026-02-05)
- **결정**: Drag & Drop 방식의 파일 업로드 기능 구현, 중복 파일 덮어쓰기 확인 포함.
- **이유**:
  - 직관적인 UX: 파일을 드래그하거나 클릭하여 쉽게 업로드.
  - 현대적인 파일 관리자 표준: Google Drive, Dropbox 등 주요 서비스에서 사용.
  - Space 기반 워크플로우와 자연스럽게 통합.
  - 안전한 덮어쓰기: 사용자 확인 후 기존 파일 덮어쓰기 가능.
- **구현**:
  - **백엔드**:
    - `POST /api/browse/upload` 엔드포인트 추가.
    - multipart/form-data로 파일 수신 (최대 32MB).
    - `targetPath` 파라미터로 업로드 대상 디렉토리 지정.
    - `overwrite` 파라미터 (선택): `true`일 때 기존 파일 덮어쓰기.
    - Space 경로 검증: `isPathAllowed`로 대상 경로가 Space 내부인지 확인.
    - 파일 중복 처리:
      - `overwrite=false` (기본값): 동일 이름 파일 존재 시 409 Conflict 에러.
      - `overwrite=true`: 기존 파일 덮어쓰기 (`os.Create`가 자동으로 덮어씀).
    - `os.Create` + `io.Copy`로 파일 저장.
    - 실패 시 부분 저장된 파일 정리 (`os.Remove`).
  - **프론트엔드**:
    - Ant Design `Upload.Dragger` 컴포넌트 사용.
    - `customRequest`로 커스텀 업로드 로직 구현.
    - `performUpload` 함수로 업로드 로직 분리 (재사용 가능).
    - 409 에러 처리:
      - `Modal.confirm`으로 덮어쓰기 확인 모달 표시.
      - 확인 시 `overwrite=true`로 재업로드.
      - 취소 시 업로드 중단.
    - FormData로 파일, targetPath, overwrite 전송.
    - 업로드 성공 시 `message.success` 표시 및 목록 자동 새로고침.
    - `showUploadList: false`로 기본 업로드 목록 숨김 (즉시 새로고침으로 대체).
    - FolderContent 상단 Breadcrumb 아래 배치.
- **보안 고려사항**:
  - Space 경로 검증: Space 외부 경로 업로드 차단 (403 에러).
  - 파일 크기 제한: 32MB (서버 메모리 보호).
  - 덮어쓰기 확인: 사용자 명시적 확인 없이는 덮어쓰기 불가.
- **대안 검토**:
  - 별도 업로드 버튼: Drag & Drop보다 덜 직관적.
  - 무제한 파일 크기: 서버 메모리 고갈 위험.
  - 중복 파일 자동 덮어쓰기: 데이터 손실 위험, 사용자 확인 필수.
  - 중복 파일 자동 이름 변경: 사용자가 예상하지 못한 파일명, 혼란 야기.
- **수정 파일**:
  - `apps/backend/internal/browse/handler/browse_handler.go` (handleUpload, RegisterRoutes)
  - `apps/frontend/src/features/browse/components/FolderContent.tsx` (Upload.Dragger, 덮어쓰기 확인 모달 추가)
- **결과**: Drag & Drop 파일 업로드 정상 작동, 중복 파일 덮어쓰기 확인 모달 정상 작동.

### 뷰 전환 기능 구현 (2026-02-05)
- **결정**: 테이블 뷰와 그리드(앨범) 뷰를 전환할 수 있는 기능 구현.
- **이유**:
  - 사용자 선호도: 일부 사용자는 상세 정보를 선호하고, 일부는 시각적 탐색을 선호.
  - 파일 타입별 최적화: 이미지는 그리드가, 문서는 테이블이 더 적합.
  - 현대적인 파일 관리자 표준: Finder, Google Drive, Dropbox 모두 뷰 전환 기능 제공.
  - 유연성: 사용자가 상황에 따라 적합한 뷰 선택 가능.
- **구현**:
  - **뷰 전환 UI**:
    - Button.Group으로 두 버튼 묶음.
    - Breadcrumb 우측에 배치 (justify-space-between).
    - 활성 버튼은 `type="primary"`로 강조.
    - 아이콘: UnorderedListOutlined (테이블), AppstoreOutlined (그리드).
  - **테이블 뷰** (기존):
    - Ant Design Table 컴포넌트.
    - 파일명, 수정일, 크기 정보 표시.
    - 정렬, 더블 클릭 이동, 우클릭 메뉴 지원.
  - **그리드 뷰** (신규):
    - Ant Design Row/Col + Card 컴포넌트.
    - 반응형 그리드: xs=12 (2열), sm=8 (3열), md=6 (4열), lg=4 (6열), xl=3 (8열).
    - 카드 내용:
      - 큰 아이콘 (48px): 폴더(노란색), 파일(회색).
      - 파일 이름 (12px, word-break).
      - 파일 크기 (11px, 파일만).
    - 더블 클릭 이동, 우클릭 메뉴 기능 유지.
    - 중앙 정렬, 카드 호버 효과.
  - **상태 관리**:
    - `viewMode` state ('table' | 'grid').
    - 조건부 렌더링으로 뷰 전환.
    - 기본값: 'table'.
- **디자인 고려사항**:
  - 8px 그리드 시스템 준수: gutter=[16, 16], padding=16px.
  - 일관된 아이콘 색상: 폴더(#ffca28), 파일(#8c8c8c).
  - Card bodyStyle로 padding 조정 (16px 8px).
  - word-break로 긴 파일명 처리.
- **대안 검토**:
  - 리스트 뷰 추가: 테이블과 유사하여 불필요.
  - 아이콘 크기 조정 슬라이더: 복잡도 증가, 우선순위 낮음.
  - 뷰 모드 localStorage 저장: 현재는 세션별 초기화, 추후 고려.
- **수정 파일**:
  - `apps/frontend/src/features/browse/components/FolderContent.tsx` (뷰 전환 버튼, 그리드 뷰 추가)
- **결과**: 테이블 ↔ 그리드 양방향 전환 정상 작동, 그리드 뷰 반응형 정상 작동.

### 업로드 UI 개선 (2026-02-05)
- **결정**: Upload.Dragger 섹션 제거, 전체 영역 드래그 앤 드롭 지원, 업로드 버튼 추가.
- **이유**:
  - 화면 공간 효율성: 별도 업로드 섹션이 화면 공간을 많이 차지.
  - 현대적인 UX: Google Drive, Dropbox 등은 전체 영역 드래그 지원.
  - 직관성: 파일 탐색기 어디에나 드롭 가능.
  - 일관성: 뷰 전환 버튼과 업로드 버튼을 같은 영역에 배치.
- **구현**:
  - **Upload.Dragger 제거**:
    - 기존 Upload.Dragger 섹션 완전 제거.
    - 파일 목록이 화면을 더 넓게 사용.
  - **전체 영역 드래그 앤 드롭**:
    - 최상위 div에 드래그 이벤트 리스너 추가.
    - `onDragEnter`, `onDragLeave`, `onDragOver`, `onDrop`.
    - `isDragging` state로 드래그 상태 관리.
    - 드래그 중 오버레이 표시:
      - 반투명 파란색 배경 (rgba(24, 144, 255, 0.1)).
      - 파란색 점선 테두리 (2px dashed #1890ff).
      - 중앙 정렬된 아이콘 + 메시지 ("파일을 놓아 업로드").
      - z-index: 999, position: absolute.
  - **업로드 버튼**:
    - 위치: Breadcrumb 우측, 뷰 전환 버튼 옆.
    - Space 컴포넌트로 버튼들 그룹화.
    - UploadOutlined 아이콘 + "업로드" 텍스트.
    - 숨겨진 file input (display: none).
    - 버튼 클릭 시 fileInputRef.current?.click().
  - **업로드 로직 통합**:
    - `handleFileUpload` 함수로 드래그/버튼 업로드 통합.
    - 중복 확인 및 덮어쓰기 모달 기능 유지.
    - performUpload 함수 재사용.
- **디자인 고려사항**:
  - 드래그 오버레이: 파란색(#1890ff) 테마 일관성.
  - 아이콘 크기: 64px (눈에 잘 띄도록).
  - pointerEvents: none (오버레이가 드롭 이벤트 방해 방지).
- **대안 검토**:
  - Upload.Dragger 유지: 화면 공간 낭비, 중복 기능.
  - 작은 드롭 영역 추가: 현대적인 UX와 맞지 않음.
  - 오버레이 없이 드래그만 지원: 시각적 피드백 부족.
- **수정 파일**:
  - `apps/frontend/src/features/browse/components/FolderContent.tsx` (드래그 이벤트, 업로드 버튼 추가)
- **결과**: 전체 영역 드래그 앤 드롭 정상 작동, 업로드 버튼 정상 작동, 화면 공간 효율화.

### Breadcrumb 절대 경로 버그 수정 (2026-02-06)
- **문제**: 하위 폴더(2+ depth) 이동 시 breadcrumb이 절대 경로로 표시되는 버그.
- **원인**:
  - FolderTree에서 Space 노드가 아닌 하위 폴더 선택 시 Space 정보 없이 경로만 전달.
  - FolderContent에서 폴더 더블 클릭 시 `onPathChange(path)` 호출로 경로만 업데이트.
  - `selectedSpace` state가 현재 경로와 동기화되지 않아 breadcrumb 로직이 실패.
  - Breadcrumb 로직: `if (selectedSpace && selectedPath.startsWith(selectedSpace.space_path))`
  - 경로가 다른 Space에 속하거나 selectedSpace가 없으면 절대 경로로 fallback.
- **결정**: `handlePathSelect` 함수에서 Space가 명시되지 않으면 자동으로 찾도록 개선.
- **이유**:
  - 사용자가 어떤 방식으로 탐색하든 (사이드바 클릭, 더블 클릭, breadcrumb 클릭) 일관된 UX 제공.
  - Space 중심 워크플로우 유지: 항상 Space 기준 상대 경로 표시.
  - 코드 중복 방지: FolderTree, FolderContent 모두 수정 불필요.
- **구현**:
  - `MainLayout/index.tsx`의 `handlePathSelect(path, space?)` 수정:
    ```typescript
    if (space) {
      setSelectedSpace(space);
    } else {
      const matchedSpace = spaces?.find(s => path.startsWith(s.space_path));
      setSelectedSpace(matchedSpace);
    }
    ```
  - `path`가 어떤 Space의 하위 경로인지 자동 탐색.
  - 매칭되는 Space를 `selectedSpace`에 설정.
  - 매칭되는 Space가 없으면 `undefined` 설정 (절대 경로 표시).
- **대안 검토**:
  - FolderTree에서 항상 Space 정보 전달: 복잡한 로직, 여러 파일 수정 필요.
  - FolderContent에서 Space 찾기: 중복 로직, MainLayout에서 처리하는 것이 더 효율적.
  - Breadcrumb에서 Space 찾기: 로직이 여러 곳에 분산, 유지보수 어려움.
- **수정 파일**:
  - `apps/frontend/src/components/layout/MainLayout/index.tsx` (handlePathSelect 로직 개선)
- **결과**: 하위 폴더(2+ depth) 탐색 시 breadcrumb이 항상 상대 경로로 정상 표시.

### 그리드 뷰 기본값 변경 (2026-02-06)
- **결정**: 파일 탐색기의 기본 뷰를 테이블에서 그리드(앨범)로 변경.
- **이유**:
  - 사용자 요청: 기본적으로 앨범 형식을 선호.
  - 시각적 탐색 용이성: 그리드 뷰가 파일/폴더 구조를 한눈에 파악하기 쉬움.
  - 현대적인 파일 관리자 트렌드: Finder, Google Drive 등 대부분 그리드 뷰 기본 제공.
  - 이미지/미디어 중심 작업: 그리드 뷰가 파일 미리보기에 더 적합.
- **구현**:
  - `FolderContent.tsx`의 `viewMode` state 초기값 변경.
  - 기존: `useState<'table' | 'grid'>('table')`
  - 변경: `useState<'table' | 'grid'>('grid')`
  - 뷰 전환 기능은 유지: 사용자가 원하면 테이블 뷰로 전환 가능.
- **대안 검토**:
  - localStorage에 사용자 선호 뷰 저장: 추후 고려, 현재는 세션별 초기화.
  - 파일 타입별 자동 뷰 전환: 복잡도 증가, 우선순위 낮음.
  - 그리드 뷰만 제공: 유연성 부족, 사용자 선택권 제거.
- **수정 파일**:
  - `apps/frontend/src/features/browse/components/FolderContent.tsx` (viewMode 기본값 변경)
- **결과**: Space 선택 시 그리드 뷰가 기본으로 표시, 뷰 전환 기능 정상 작동.

### 사이드바 트리 노드 증식 버그 수정 (2026-02-07)
- **문제**: 여러 Space를 열고 닫을 때 하위 폴더 노드가 중복 생성.
- **원인**: 같은 디렉토리를 가리키는 Space들의 하위 노드가 파일 경로를 key로 사용하여 Ant Design Tree key 충돌.
- **결정**: 자식 노드 key에 부모 Space prefix를 붙여 유일성 보장 + `expandedKeys` 명시적 상태 관리.
- **구현**:
  - key 형식: `space-{id}::{filePath}` (Space 하위), 기존 경로 (비-Space).
  - `handleSelect`에서 `::` 구분자로 실제 경로 추출.
  - `expandedKeys` state + `onExpand` 핸들러로 확장 상태 제어.
  - treeData 초기화 시 `loadedKeys`, `expandedKeys` 동시 초기화.
- **수정 파일**: `FolderTree.tsx`

### 서버 상태 표시 개선 (2026-02-07)
- **결정**: Status popover를 텍스트 바로 아래로 이동하고, 호스트/포트/경로 정보 추가.
- **이유**:
  - 기존 popover가 텍스트에서 떨어져 표시되어 연결성이 약함.
  - 사용자가 각 프로토콜의 접근 정보를 한눈에 확인할 수 있어야 함.
- **구현**:
  - 백엔드: `net.InterfaceAddrs()`로 IPv4 주소 수집, `ProtocolStatus`에 `Port`/`Path` 추가.
  - 프론트엔드: `placement="bottomLeft"`, 포트/경로 inline 표시, 호스트 목록 섹션 추가.
- **수정 파일**: `handler.go`, `main.go`, `types.ts`, `ServerStatus.tsx`

### WebDAV 루트 디렉토리 가상 Space 목록 (2026-02-07)
- **결정**: `/dav/` 접근 시 커스텀 `webdav.FileSystem`으로 모든 Space를 가상 폴더로 노출.
- **이유**:
  - WebDAV 클라이언트(Finder 등)가 `/dav/`에 마운트하면 모든 Space를 볼 수 있어야 함.
  - 기존 구현은 `/dav/{spaceName}` 형태만 지원하여 루트 접근 시 400 에러.
- **구현**:
  - `SpaceFS`: `webdav.FileSystem` 인터페이스 구현.
  - 루트(`/`): `Readdir`에서 Space 목록을 가상 디렉토리 FileInfo로 반환.
  - `/{spaceName}/...`: Space의 `SpacePath`로 실제 OS 파일시스템 위임.
  - 루트 Mkdir/RemoveAll/Rename 거부 (Space 관리는 API로만).
  - 경로 탈출 방지: `strings.HasPrefix(realPath, sp.SpacePath)`.
- **대안 검토**:
  - per-space 핸들러 유지 + 루트용 별도 핸들러: 중복 코드, 복잡도 증가.
  - 하나의 SpaceFS로 통합: 단일 핸들러로 루트와 하위 모두 처리, 더 깔끔.
- **수정 파일**: `spacefs.go`(신규), `service.go`, `webdav_handler.go`

### 레이아웃 여백 16px 통일 (2026-02-07)
- **결정**: 모든 레이아웃 영역의 수평 패딩을 `16px` (8-grid 2×8)로 일괄 통일.
- **이유**:
  - Header의 antd 기본 패딩(`0 50px`)이 50px로 8-grid 위반.
  - 사이드바 헤더의 세로 패딩 `12px`가 8-grid 위반.
  - 사이드바(16px), 메인 콘텐츠(24px) 간 수평 패딩 불일치.
  - 시각적으로 "Cohesion" 텍스트와 "Spaces" 라벨이 정렬되지 않음.
- **구현**:
  - Header: `padding: '0 16px'` 명시적 설정 (antd 기본값 오버라이드).
  - 사이드바 헤더: `'12px 16px'` → `'16px'` (상하좌우 균일).
  - 사이드바 트리: `'8px'` → `'8px 16px'` (수평만 통일, 수직은 컴팩트 유지).
  - 메인 콘텐츠: `'24px'` → `'16px'` (수평 패딩 통일).
- **대안 검토**:
  - `24px` 기준 통일: 사이드바에 과도한 여백, 300px 폭에서 비효율적.
  - `8px` 기준 통일: 너무 좁아 답답한 느낌.
- **수정 파일**:
  - `apps/frontend/src/components/layout/MainLayout/index.tsx` (Header padding)
  - `apps/frontend/src/components/layout/MainLayout/MainSider.tsx` (사이드바 헤더, 트리 padding)
  - `apps/frontend/src/features/browse/components/FileExplorer.tsx` (메인 콘텐츠 padding)
- **결과**: 모든 영역 수평 패딩 16px 통일, 다크/라이트 모드 및 그리드/테이블 뷰 모두 정상.

### 컨텍스트 메뉴 UI 개선 — Ant Design Dropdown 전환 (2026-02-08)
- **결정**: 기존 `Menu` + `position: fixed` 인라인 스타일 → Ant Design `Dropdown` 컴포넌트 래핑 공통 `ContextMenu` 생성.
- **이유**:
  - FolderContent, FolderTree에서 동일한 컨텍스트 메뉴 패턴 (상태관리 + document click 리스너) 중복.
  - 화면 경계 처리 없음 (메뉴가 화면 밖으로 잘릴 수 있음).
  - 애니메이션 없이 즉시 출현/사라짐.
  - ESC 키 닫기 미지원.
- **구현**:
  - `src/components/ContextMenu.tsx`: Ant Design `Dropdown` + `trigger={[]}` 제어 모드.
  - 투명 trigger span을 클릭 좌표에 `position: fixed`로 배치, Dropdown이 자동 위치 보정.
  - `useEffect`로 외부 클릭(document click) + ESC 키(keydown) 리스너 등록.
  - FolderContent, FolderTree: `Menu` import 제거, `ContextMenu` 사용, 중복 useEffect 제거.
- **대안 검토**:
  - 커스텀 컴포넌트 (framer-motion): 과도한 개발 비용, Ant Design 일관성 저하.
  - `Dropdown trigger={['contextMenu']}`: Table onRow / Tree onRightClick과 호환 어려움.
- **수정 파일**:
  - `apps/frontend/src/components/ContextMenu.tsx` (신규)
  - `apps/frontend/src/features/browse/components/FolderContent.tsx`
  - `apps/frontend/src/features/browse/components/FolderTree.tsx`
- **결과**: 화면 경계 자동 보정, 페이드 애니메이션, ESC/외부 클릭 닫기, 중복 코드 제거.

### 새 폴더 만들기 기능 구현 (2026-02-08)
- **결정**: 빈 영역 우클릭 시 "새 폴더 만들기" 메뉴를 표시하고 모달로 폴더 생성.
- **이유**:
  - 파일 관리 기본 기능: 사용자가 직접 폴더 구조를 만들 수 있어야 함.
  - 파일 복사/이동 기능(Task 2)의 기반: 빈 영역 컨텍스트 메뉴 인프라 구축.
  - 직관적인 UX: Google Drive, Finder 등 주요 파일 관리자와 일관된 경험.
  - 안전한 생성: 중복 확인 및 특수문자 검증으로 파일시스템 보호.
- **구현**:
  - **백엔드**:
    - `POST /api/browse/create-folder` 엔드포인트 추가.
    - 요청: `{ parentPath, folderName }`.
    - 검증 순서:
      1. POST 메서드 확인
      2. Request body 파싱 및 필드 검증 (빈 값 체크)
      3. `parentPath` Space 경로 검증 (`isPathAllowed`)
      4. 부모 디렉토리 존재 및 디렉토리 여부 확인 (`os.Stat`)
      5. 폴더명 유효성 검증 (`/`, `\`, `:`, `*`, `?`, `"`, `<`, `>`, `|` 금지)
      6. 중복 확인 (동일 이름 폴더 존재 시 409 Conflict)
      7. `os.Mkdir(folderPath, 0755)` 실행
      8. 성공 응답 반환 (path, name 포함)
    - 에러 코드: 400 (잘못된 요청), 403 (Space 외부), 404 (부모 없음), 409 (중복), 500 (OS 오류).
  - **프론트엔드**:
    - **빈 영역 감지**:
      - 기존: `e.currentTarget === e.target` (너무 엄격, Grid View/Table View에서 실패).
      - 개선: `!target.closest('.ant-card') && !target.closest('tr')` (카드나 테이블 행이 아닌 곳).
    - **빈 영역 컨텍스트 메뉴**:
      - `emptyAreaMenu` state로 빈 영역 메뉴 상태 관리.
      - `emptyAreaMenuItems`: "새 폴더 만들기" (FolderOutlined 아이콘).
      - ContextMenu 컴포넌트 재사용.
    - **폴더 생성 모달**:
      - `createFolderModal` state로 모달 상태 및 폴더명 관리.
      - Input autoFocus, Enter 키로 생성, 취소/생성 버튼.
      - `handleCreateFolder`: API 호출 → 성공 시 message.success → 목록 새로고침.
    - **API 호출**:
      - `POST /api/browse/create-folder` with `{ parentPath: selectedPath, folderName }`.
      - 409 에러 시 "폴더 이미 존재" 메시지.
- **대안 검토**:
  - 별도 "새 폴더" 버튼: 화면 공간 낭비, 덜 직관적.
  - 파일/폴더 메뉴에 "새 폴더" 추가: 빈 영역 메뉴가 더 직관적.
  - 빈 영역 더블 클릭으로 생성: 실수로 생성 가능, 명시적 메뉴가 더 안전.
  - 자동 이름 생성 ("새 폴더", "새 폴더 2", ...): 사용자 의도와 다를 수 있음, 직접 입력이 더 명확.
- **수정 파일**:
  - `apps/backend/internal/browse/handler/browse_handler.go` (handleCreateFolder, RegisterRoutes)
  - `apps/frontend/src/features/browse/components/FolderContent.tsx` (빈 영역 메뉴, 모달, 감지 로직)
- **결과**: 빈 영역 우클릭 → 메뉴 → 모달 → 폴더 생성 → 자동 새로고침 흐름 정상 작동.

### TypeScript 빌드 에러 수정 (2026-02-08)
- **문제**: 프론트엔드 빌드 시 TypeScript 타입 에러 발생.
  - `Upload`, `UploadProps` 임포트되었으나 사용되지 않음 (TS6133, TS6196).
  - 이벤트 핸들러 파라미터에 타입 명시 없음 (TS7006, TS7031).
  - 빌드 실패로 런타임에서 이전 코드가 실행되어 null 참조 에러 발생.
- **결정**: 엄격한 타입 체크를 준수하여 모든 파라미터에 명시적 타입 지정.
- **이유**:
  - TypeScript strict mode: 타입 안정성 향상 및 런타임 에러 예방.
  - 빌드 성공: 최신 코드가 브라우저에 반영되어야 버그 수정 효과 확인 가능.
  - 코드 가독성: 명시적 타입은 IDE 자동완성 및 문서화에 도움.
- **구현**:
  - **FolderContent.tsx**:
    - 미사용 import 제거: `Upload`, `UploadProps`.
    - `onContextMenu`: `(e: React.MouseEvent<HTMLElement>) => ...`
    - `onChange` (rename modal): `(e: React.ChangeEvent<HTMLInputElement>) => ...`
    - `onChange` (create folder modal): `(e: React.ChangeEvent<HTMLInputElement>) => ...`
  - **FolderTree.tsx**:
    - `handleExpand`: `(keys: React.Key[]) => ...`
    - `handleRightClick`: `({ event, node }: { event: React.MouseEvent; node: any }) => ...`
- **대안 검토**:
  - `@ts-ignore` 사용: 타입 체크 우회는 런타임 에러 위험 증가, 유지보수성 저하.
  - `any` 타입 사용: 타입 안정성 손실, 버그 탐지 어려움.
  - 타입 명시: 가장 안전하고 명확한 방법.
- **수정 파일**:
  - `apps/frontend/src/features/browse/components/FolderContent.tsx`
  - `apps/frontend/src/features/browse/components/FolderTree.tsx`
- **결과**: 빌드 성공, 브라우저 새로고침 후 정상 동작 (null 참조 에러 해결).

### 파일 브라우저 정렬 기능 구현 (2026-02-09)
- **결정**: 클라이언트 정렬 방식으로 폴더 우선 정렬 구현.
- **이유**:
  - 현재 폴더 내 파일만 정렬하므로 클라이언트 정렬로 충분 (수백 개 파일도 빠름).
  - 백엔드 수정 불필요, 프론트엔드만 수정하여 빠르게 구현.
  - useMemo로 최적화하여 불필요한 재정렬 방지.
- **구현**:
  - **정렬 상태**: `sortBy` (name/modTime/size), `sortOrder` (ascend/descend).
  - **정렬 로직**:
    1. 폴더 우선: `a.isDir !== b.isDir ? (a.isDir ? -1 : 1)`
    2. sortBy 기준 정렬: localeCompare (이름), getTime (수정일), 숫자 비교 (크기)
    3. sortOrder 적용: ascend는 그대로, descend는 결과 반전
  - **그리드 뷰**: Select 드롭다운으로 6가지 정렬 옵션 제공.
  - **테이블 뷰**: Ant Design Table의 onChange 핸들러로 정렬 상태 업데이트.
  - **뷰 전환**: sortConfig state를 공유하여 뷰 전환 시 정렬 유지.
- **대안 검토**:
  - 서버 정렬: 불필요한 복잡도, 클라이언트 정렬로 충분.
  - 정렬 없이 백엔드 순서대로 표시: 사용자 경험 저하, 파일 관리 어려움.
  - 폴더와 파일 섞어서 정렬: 직관성 떨어짐, 대부분의 파일 관리자가 폴더 우선 채택.
- **기본 정렬**: 폴더 우선 + 이름 오름차순 (가장 직관적).
- **수정 파일**:
  - `apps/frontend/src/features/browse/components/FolderContent.tsx`
- **결과**: 모든 정렬 옵션 정상 작동, 뷰 전환 시 정렬 유지 확인.

### 드래그 앤 드롭 파일 이동 기능 (2026-02-09)
- **결정**: Google Drive 스타일의 드래그 앤 드롭으로 파일/폴더를 다른 폴더로 이동하는 기능 구현.
- **이유**:
  - 직관적인 UX: 사용자가 익숙한 드래그 앤 드롭 인터페이스 제공.
  - 작업 효율성: 우클릭 메뉴보다 빠른 파일 이동.
  - 다중 이동 지원: 선택된 여러 파일을 한 번에 이동 가능.
- **구현**:
  - **드래그 소스**:
    - 모든 Card와 Table Row에 `draggable={true}` 속성 추가.
    - `onDragStart`: 선택되지 않은 항목 드래그 시 자동 선택, dataTransfer에 경로 목록 저장.
    - 데이터 타입: `application/json` with `{type: 'cohesion-internal', paths: [...]}`
  - **드롭 타겟**:
    - 폴더에만 드롭 가능, 파일에는 불가.
    - `onDragOver`: 폴더에 호버 시 `dragOverFolder` 상태로 시각적 피드백 (파란 테두리/배경).
    - `onDrop`: 폴더에 드롭 시 해당 폴더로 이동, 자기 자신 이동 방지.
    - 빈 영역 드롭: 현재 폴더에 이동 (같은 폴더면 무시).
  - **외부 파일 업로드와 구분**:
    - `dataTransfer.files.length > 0`: 외부 파일 업로드.
    - `dataTransfer.getData('application/json')`: 내부 파일 이동.
    - 외부 파일 드래그 시에만 `isDragging` 상태 활성화 (오버레이 표시).
  - **텍스트 선택 방지**:
    - Card와 Table Row에 `userSelect: 'none'` CSS 적용.
    - 드래그 중 텍스트 선택 안 됨.
  - **시각적 피드백**:
    - 드롭 가능한 폴더: 파란 테두리 (그리드: 2px dashed, 테이블: 배경색).
    - 선택된 항목: 파란 테두리 + 배경색.
- **제약사항**:
  - 자기 자신으로 이동 방지 (message.warning 표시).
  - Space 외부 이동 방지 (기존 move API 검증 활용).
  - 부모 폴더를 자식 폴더로 이동 방지 (백엔드 검증).
- **기존 기능과의 호환성**:
  - 기존 우클릭 메뉴 이동/복사 기능 유지.
  - 외부 파일 업로드 드래그 앤 드롭 정상 작동.
  - 다중 선택 기능과 완벽 통합.
- **대안 검토**:
  - 우클릭만 사용: 작업 효율성 떨어짐, Google Drive 등 경쟁 제품 대비 UX 열등.
  - 별도 버튼으로 이동: 단계가 많아 불편함.
  - 드래그 앤 드롭: 가장 직관적이고 효율적.
- **수정 파일**:
  - `apps/frontend/src/features/browse/components/FolderContent.tsx`
- **결과**: 단일/다중 파일 드래그 이동 성공, 외부 파일 업로드와 충돌 없음, 텍스트 선택 방지 확인.

### Shift 클릭 범위 선택 버그 수정 (2026-02-09)
- **문제**: 정렬된 상태에서 Shift+클릭으로 범위 선택 시 원치 않은 항목 선택.
- **원인**: `handleItemClick`에서 `content` 배열을 사용하지만, 화면에는 `sortedContent`가 표시되어 인덱스 불일치.
- **결정**: `content` 대신 `sortedContent` 사용.
- **이유**:
  - 사용자가 화면에서 보는 순서와 실제 선택되는 항목이 일치해야 직관적.
  - 정렬 기능과 다중 선택 기능이 함께 사용될 때 필수적인 수정.
- **구현**:
  - `handleItemClick`의 Shift+클릭 범위 선택 로직에서 `content[i]` → `sortedContent[i]`로 변경.
  - 인덱스 계산은 동일하게 유지 (화면에 표시된 순서 기준).
- **수정 파일**:
  - `apps/frontend/src/features/browse/components/FolderContent.tsx`
- **테스트**: 크기 오름차순 정렬 후 첫 항목부터 마지막 항목까지 Shift+클릭으로 9개 항목 선택 성공.
- **결과**: 정렬 상태와 무관하게 화면 순서대로 범위 선택 정상 작동.

## 의존성 관리
### gopsutil v4로 업그레이드 (2026-02-09)
- **결정**: `github.com/shirou/gopsutil` v3.21.11에서 v4.26.1로 업그레이드.
- **이유**:
  - macOS 12.0에서 deprecated된 `IOMasterPort` API 사용으로 인한 빌드 경고 제거.
  - v4에서 해당 API가 `IOMainPort`로 업데이트되어 경고 해결.
  - 최신 버전 사용으로 향후 macOS 호환성 확보.
- **구현**:
  - `go get github.com/shirou/gopsutil/v4@latest` 실행.
  - import 경로 변경: `github.com/shirou/gopsutil/disk` → `github.com/shirou/gopsutil/v4/disk`.
  - v3는 자동으로 제거되지 않고 `go.mod`에 남아있음 (하위 호환성).
- **영향**:
  - `apps/backend/internal/browse/service.go`의 디스크 파티션 정보 조회 기능.
  - API 변경 없음, 기존 코드와 동일하게 동작.
  - 빌드 시 더 이상 deprecation 경고 출력되지 않음.
- **대안 검토**:
  - 경고 무시: 향후 macOS 버전에서 API 제거 시 빌드 실패 가능성.
  - 다른 라이브러리 사용: gopsutil이 Go에서 가장 널리 사용되는 시스템 정보 라이브러리.
- **수정 파일**:
  - `apps/backend/go.mod`, `apps/backend/go.sum` (의존성 업데이트)
  - `apps/backend/internal/browse/service.go` (import 경로 변경)
- **결과**: 빌드 경고 제거, 정상 작동 확인.

## 전역 상태 관리
### Zustand 도입 (2026-02-09)
- **결정**: Zustand를 전역 상태 관리 라이브러리로 도입.
- **이유**:
  - Props Drilling 제거: Space 데이터를 3단계로 전달하는 불편함 해소.
  - 일관된 상태 관리: Context API와 로컬 state가 혼재된 상태를 통일.
  - 확장성: 새로운 전역 상태 추가 시 간단한 store 생성으로 해결.
  - 경량성: Redux보다 가볍고 간단한 API (bundle size 약 1.2KB).
  - 성능: 선택적 구독으로 불필요한 리렌더링 방지.
- **구조**: 기능별 독립 Store
  - `themeStore`: 다크모드 설정, localStorage 연동 (persist middleware).
  - `contextMenuStore`: 전역 컨텍스트 메뉴 상태 관리.
  - `spaceStore`: Space 목록, 선택된 Space, CRUD actions.
  - `browseStore`: 파일 탐색 경로, 컨텐츠 (예정).
- **마이그레이션 완료**:
  - **Phase 1 (Theme Store)**:
    - `themeStore.ts` 생성, localStorage persist 설정.
    - `MainLayout`에서 로컬 isDarkMode state → themeStore.
    - useState 제거, useThemeStore 사용.
  - **Phase 2 (Context Menu Store)**:
    - `contextMenuStore.ts` 생성.
    - `ContextMenu.tsx` 컴포넌트: props → store 직접 접근.
    - `FolderTree.tsx`, `FolderContent.tsx`: `useContextMenu()` → `useContextMenuStore()`.
    - `ContextMenuContext.tsx` 완전 제거.
    - `MainLayout`에서 `ContextMenuProvider` 제거, `<ContextMenu />` 직접 렌더링.
  - **Phase 3 (Space Store)**:
    - `spaceStore.ts` 생성: `fetchSpaces`, `createSpace`, `deleteSpace` actions.
    - `MainLayout`: `useSpaces()` → `useSpaceStore()`.
    - `MainSider`: `spaces`, `onSpaceCreated` props 제거, store 직접 접근.
    - `FolderTree`: `spaces` prop 제거, store 직접 접근.
    - `DirectorySetupModal`: `useCreateSpace()` → store의 `createSpace` action.
    - `useCreateSpace`, `useDeleteSpace` 훅 제거 (기능 store로 통합).
  - **Phase 4 (Browse Store)** (완료):
    - `browseStore.ts` 생성: `selectedPath`, `selectedSpace`, `content`, `isLoading`, `error` 상태 + `setPath`, `fetchDirectoryContents`, `clearContent` actions.
    - `MainLayout`: `pathState` 로컬 state → browseStore, Outlet context 제거.
    - `handlePathSelect`: Space가 명시되지 않으면 경로에서 자동으로 Space 탐지 (`spaces.find(s => path.startsWith(s.space_path))`).
    - `FileExplorer`: Outlet context 제거, props 전달 제거, `<FolderContent />` 단독 렌더링.
    - `FolderContent`: `selectedPath`, `selectedSpace`, `content` props 제거 → store 직접 접근.
    - API 호출 후 `setContent` 중복 제거: `fetchDirectoryContents`가 이미 store 업데이트하므로 8개 위치에서 `setContent` 호출 제거.
    - 미사용 import 제거: `Space` 타입, `useSpaceStore`, `get` 파라미터.
- **마이그레이션 완료**: 모든 Phase (1~4) 완료, Props Drilling 완전 제거, 전역 상태 일관성 확보.
- **수정 파일**:
  - 생성: `stores/themeStore.ts`, `stores/contextMenuStore.ts`, `stores/spaceStore.ts`.
  - 수정: `MainLayout/index.tsx`, `MainSider.tsx`, `ContextMenu.tsx`, `FolderTree.tsx`, `FolderContent.tsx`, `DirectorySetupModal.tsx`.
  - 제거: `contexts/ContextMenuContext.tsx`.
- **검증**: TypeScript 빌드 성공, 미사용 import 제거, ESLint 경고 없음.

## 성능 최적화
### API 중복 호출 최적화 (2026-02-09)
- **문제**: Space 클릭 시 동일한 API가 3번 호출되어 성능 저하.
  - `/api/browse?path=...` 엔드포인트가 중복 호출.
  - 사용자 경험 저하 (불필요한 네트워크 요청, 서버 부하).
- **원인 분석** (Chrome extension 네트워크 추적):
  1. **React StrictMode**: 개발 환경에서 useEffect를 두 번 실행 (+1번).
  2. **두 개의 독립적인 setState**: `selectedPath`와 `selectedSpace` 각각 호출.
     - 각 setState마다 리렌더링 발생 → FolderContent의 useEffect 실행.
  3. **useEffect 의존성**: `[selectedPath, fetchDirectoryContents]`
     - fetchDirectoryContents 함수 참조 변경 시 추가 실행 가능성.
- **결정**: 단일 state 객체로 통합하여 리렌더링 최소화.
- **이유**:
  - React의 배칭(batching)은 이벤트 핸들러 내에서 자동으로 작동하지만, 별개의 state 업데이트는 각각 리렌더링을 트리거할 수 있음.
  - 단일 객체로 관리하면 한 번의 setState로 모든 값 업데이트 → 리렌더링 1회.
  - StrictMode는 프로덕션에서 자동 비활성화되므로, 개발 환경 최적화로 제거 가능.
- **구현**:
  - **StrictMode 제거**: `main.tsx`에서 `<StrictMode>` 래퍼 제거.
  - **단일 state 통합**:
    ```typescript
    // 변경 전
    const [selectedPath, setSelectedPath] = useState<string>('');
    const [selectedSpace, setSelectedSpace] = useState<Space | undefined>();

    // 변경 후
    const [pathState, setPathState] = useState<{ path: string; space?: Space }>({ path: '' });
    ```
  - **useCallback 메모이제이션**: `handlePathSelect` 함수 최적화.
  - **단일 setState**: 한 번의 `setPathState({ path, space })` 호출.
- **결과**:
  - **3번 → 2번 호출**로 감소 (33% 개선).
  - 불필요한 네트워크 요청 감소.
  - Chrome extension 브라우저 테스트로 검증 완료.
- **남은 이슈**:
  - 여전히 2번 호출 발생 (완전한 1번 호출 미달성).
  - 추정 원인: React Router의 Outlet 이중 렌더링 또는 컴포넌트 라이프사이클.
  - 추가 조사 및 최적화 필요.
- **대안 검토**:
  - useEffect 의존성에서 fetchDirectoryContents 제거: ESLint 경고 무시 필요, 근본 해결 아님.
  - useMemo로 API 응답 캐싱: 동일 경로 재방문 시 유용하지만 초기 중복 호출은 해결 못함.
  - React Query 도입: 오버엔지니어링, 현재 상황에서는 과도.
- **수정 파일**:
  - `apps/frontend/src/main.tsx` (StrictMode 제거)
  - `apps/frontend/src/components/layout/MainLayout/index.tsx` (단일 state, useCallback)

## 에러 핸들링
### Space ID 검증 개선 (2026-02-09)
- **문제**: `/api/spaces/` (끝에 슬래시만 있는 경우) 요청 시 에러 발생.
  - `strings.TrimPrefix`로 ID 추출 시 빈 문자열 반환.
  - `strconv.ParseInt("")` 실행으로 파싱 에러 발생.
  - 에러 메시지: `"strconv.ParseInt: parsing \"\": invalid syntax"` (사용자에게 불친절).
- **결정**: `handleSpaceByID`에서 ID 파싱 전 빈 문자열 사전 체크 추가.
- **이유**:
  - 방어적 프로그래밍: 예상 가능한 잘못된 입력에 대한 명확한 처리.
  - 사용자 경험: 기술적인 에러 대신 명확한 메시지 제공.
  - 디버깅 용이성: 로그에서 문제 원인을 빠르게 파악 가능.
- **구현**:
  - `idStr == ""` 체크 추가.
  - 빈 ID: `400 Bad Request`, 메시지: `"Space ID is required"`.
  - 잘못된 형식: `400 Bad Request`, 메시지: `"Invalid space ID format"` (기존 "Invalid space ID"에서 개선).
- **대안 검토**:
  - 라우팅 변경 (`/api/spaces/` 경로 제거): 기존 API 구조 변경 불필요, 검증 추가가 더 간단.
  - 빈 ID를 목록 조회로 리다이렉트: RESTful 원칙 위반, 혼란 야기.
  - 에러 메시지만 개선: 근본 원인(빈 문자열 파싱 시도) 해결 못함.
- **추가 발견 및 수정** (브라우저 테스트 중):
  - Go의 `http.ServeMux`가 `/api/spaces` 요청을 `/api/spaces/` 패턴으로 라우팅.
  - `handleSpaceByID`에서 경로가 정확히 `/api/spaces`인 경우 `handleSpaces`로 위임하도록 수정.
  - 브라우저 테스트 (chrome-extension): 모든 케이스 정상 작동 확인.
- **수정 파일**:
  - `apps/backend/internal/space/handler/space_handler.go` (handleSpaceByID 함수)
- **결과**:
  - `/api/spaces`: 200 OK (Space 목록)
  - `/api/spaces/`: 400 Bad Request ("Space ID is required")
  - `/api/spaces/abc`: 400 Bad Request ("Invalid space ID format")

### 박스 선택 버그 수정 (2026-02-10)
- **문제 1**: 익스플로러 바깥에서도 드래그 시 박스 선택이 동작.
- **문제 2**: 드래그해도 파일/폴더가 다중선택되지 않음.
- **원인 분석**:
  - `useBoxSelection` 훅에서 이벤트 리스너를 `window` 전역에 등록.
  - 페이지 어디서나 드래그가 시작되어 컨테이너 범위 제한 없음.
  - `containerRef`를 의존성 배열에 포함하여 핸들러가 오래된 ref 참조.
  - ref.current가 null일 때 핸들러가 생성되면 이후에도 계속 null 참조.
- **결정**: 이벤트 리스너는 window에 유지하되, handleMouseDown에서 컨테이너 범위 체크.
- **이유**:
  - 컨테이너에 직접 이벤트 등록 시 ref lifecycle 문제 발생.
  - window에 등록하면 드래그가 컨테이너 밖으로 나가도 계속 추적 가능.
  - handleMouseDown에서 범위 체크하면 시작만 컨테이너 내부로 제한.
- **구현**:
  - `useBoxSelection` 훅 수정:
    - `UseBoxSelectionParams`에 `containerRef: RefObject<HTMLElement>` 추가.
    - `handleMouseDown`에서 `containerRef.current.getBoundingClientRect()` 로 범위 체크.
    - 컨테이너 외부 클릭 시 early return.
    - 카드(`ant-card`) 또는 테이블 행(`tr`) 클릭 시에도 early return.
    - 의존성 배열에서 `containerRef` 제거 (ref는 변경되지 않으므로 불필요).
  - `FolderContent.tsx` 수정:
    - `gridContainerRef = useRef<HTMLDivElement>(null)` 생성.
    - Grid를 감싸는 div에 `ref={gridContainerRef}` 연결.
    - `useBoxSelection`에 `containerRef: gridContainerRef` 전달.
- **대안 검토**:
  - 컨테이너에 직접 이벤트 등록: ref lifecycle 복잡도 증가, useEffect 재실행 필요.
  - callback ref 사용: 추가 복잡도, 불필요한 코드.
  - window 등록 + 범위 체크: 간단하고 효과적 (채택).
- **브라우저 테스트**:
  - Chrome extension으로 테스트 시도했으나 automation 한계로 정확한 검증 어려움.
  - 실제 사용자 마우스 테스트 필요.
- **수정 파일**:
  - `apps/frontend/src/features/browse/hooks/useBoxSelection.ts`
  - `apps/frontend/src/features/browse/components/FolderContent.tsx`
- **예상 결과**: 컨테이너 내부에서만 박스 선택 시작, 다중선택 정상 작동.

### 박스 선택 후 선택 해제 버그 수정 (2026-02-10)
- **문제**: 박스로 드래그한 파일들이 마우스를 놓으면 즉시 선택 해제됨.
- **원인 분석**:
  - 이벤트 순서: `mousedown` → `mousemove` → `mouseup` → **`click`**
  - `handleContainerClick`이 빈 영역 클릭으로 인식하여 `clearSelection()` 호출.
  - `useFileSelection`의 `handleContainerClick`: 카드/테이블 행이 아닌 곳 클릭 시 선택 해제.
  - 박스 선택 직후 `click` 이벤트가 발생하여 선택이 즉시 해제됨.
- **결정**: 박스 선택 직후 발생하는 `click` 이벤트를 무시하도록 수정.
- **이유**:
  - 박스 선택은 의도적인 다중 선택 동작이므로 유지되어야 함.
  - `preventDefault()`는 기본 동작만 막고 `click` 이벤트 발생 자체를 막지 못함.
  - 플래그 기반 접근이 가장 깔끔하고 명확함.
- **구현**:
  - `useBoxSelection`에 `wasRecentlySelecting` 상태 추가.
  - `handleMouseUp`에서 선택 확정 후:
    ```typescript
    setWasRecentlySelecting(true);
    setTimeout(() => setWasRecentlySelecting(false), 0);
    ```
  - `setTimeout(..., 0)`로 다음 이벤트 루프에서 플래그 해제 (click 이벤트보다 먼저).
  - `FolderContent`의 `handleContainerClick`에서 플래그 확인:
    ```typescript
    if (wasRecentlySelecting) return;
    ```
- **대안 검토**:
  - `stopPropagation()`: 다른 이벤트 핸들러에 영향, 부작용 가능.
  - `preventDefault()`: click 이벤트 발생 자체를 막지 못함.
  - 시간 기반 플래그: 타이밍 문제 가능성.
  - 이벤트 루프 기반 플래그: 가장 안정적 (채택).
- **추가 수정**:
  - TypeScript 빌드 에러 수정:
    - `useBoxSelection` containerRef 타입을 구조적 타이핑으로 변경.
    - `ColumnsType` → `TableColumnsType` import 변경 (antd v5).
    - `error.message` 타입 가드 추가.
- **수정 파일**:
  - `apps/frontend/src/features/browse/hooks/useBoxSelection.ts`
  - `apps/frontend/src/features/browse/components/FolderContent.tsx`
  - `apps/frontend/src/features/browse/components/FolderContent/FolderContentTable.tsx`
  - `apps/frontend/src/features/browse/hooks/useFileOperations.ts`
  - `apps/frontend/src/features/browse/constants.tsx`
- **테스트 결과**: 사용자 테스트 완료, 박스 선택 후 선택 상태 정상 유지.

### 모달 열 때 선택 해제 버그 수정 (2026-02-10)
- **문제**: 복사/이동 버튼 클릭 시 모달이 열리면서 선택이 해제됨.
- **원인**:
  - 버튼 클릭 → 이벤트 버블링 → `handleContainerClick` 실행.
  - `handleContainerClick`의 체크 로직:
    - 카드(`.ant-card`) 또는 테이블 행(`tr`)만 체크.
    - 버튼 클릭은 빈 영역 클릭으로 인식 → `clearSelection()` 호출.
- **결정**: 버튼과 입력 필드 클릭도 선택 유지하도록 수정.
- **이유**:
  - 사용자가 의도적으로 버튼을 클릭하는 것은 작업 수행이지 선택 해제 의도가 아님.
  - 모달 열기, 삭제 확인 등 모든 버튼 동작 시 선택 유지 필요.
  - 입력 필드도 마찬가지로 작업 중이므로 선택 유지.
- **구현**:
  ```typescript
  const isButton = target.closest('button');
  const isInput = target.closest('input');
  if (!isCard && !isTableRow && !isButton && !isInput) {
    clearSelection();
  }
  ```
- **대안 검토**:
  - `e.stopPropagation()` 사용: 모든 버튼에 추가 필요, 유지보수 어려움.
  - 선택 바에만 체크 추가: 다른 버튼(컨텍스트 메뉴 등)에서도 문제 발생 가능.
  - 포괄적인 `button`, `input` 체크: 가장 간단하고 확실 (채택).
- **수정 파일**: `apps/frontend/src/features/browse/components/FolderContent.tsx`
- **테스트 결과**: 복사/이동 버튼 클릭 시 선택 유지, 모달 정상 작동.

### 박스 선택 누적 방식 채택 (2026-02-11, #25)
- **문제**: 박스 선택 중 스크롤 시 박스를 벗어난 항목이 선택 해제되는 비직관적 UX.
  - 사용자 기대: "한 번이라도 박스에 걸린 항목은 계속 선택 상태여야 한다."
  - 기존 동작: 현재 박스와 교차하는 항목만 선택 (Viewport 좌표계).
  - 스크롤 시 새로운 항목이 선택되고 이전 항목은 해제됨.
- **원인 분석**:
  - `updateSelection`이 매번 교차 항목으로 선택 상태를 덮어씀.
  - `handleScroll`에서 현재 교차 항목만 전달하여 이전 선택이 사라짐.
  - 선택 박스는 viewport에 고정, 아이템들이 스크롤로 이동.
- **결정**: 드래그 중 교차한 모든 항목을 누적하는 방식으로 변경.
- **이유**:
  - 직관적인 UX: 대부분의 파일 탐색기(Windows, macOS)가 이 방식 사용.
  - 사용자 멘탈 모델 일치: "지나간 영역의 파일들이 선택된다".
  - 실수 방지: 우연히 스크롤해도 선택이 사라지지 않음.
  - 많은 파일 선택 시 효율적: 드래그 + 스크롤로 빠른 선택.
- **구현**:
  - `accumulatedSelection = useRef<Set<string>>(new Set())` 추가.
  - `handleMouseDown`: `accumulatedSelection` 초기화.
  - `handleMouseMove`, `handleScroll`, `handleMouseUp`:
    ```typescript
    intersected.forEach(path => accumulatedSelection.current.add(path));
    ```
  - Ctrl/Shift 모드 처리를 각 핸들러에서 직접 계산:
    - 일반 모드: `new Set(accumulatedSelection.current)` (누적된 항목만).
    - Shift 모드: `new Set([...initialSelection.current, ...accumulatedSelection.current])`.
    - Ctrl 모드: `initialSelection`에서 누적 항목 토글.
  - `updateSelection` 함수 제거 (더 이상 불필요).
- **대안 검토**:
  - **Content 좌표계**: 선택 박스를 content에 고정 (스크롤 offset 포함).
    - 장점: 선택 박스가 content와 함께 움직여 더 직관적일 수 있음.
    - 단점: 구현 복잡도 높음, 박스가 화면 밖으로 사라질 수 있음.
    - 기각 이유: 현재 viewport 좌표계를 유지하면서 누적 방식으로 UX 개선 가능.
  - **드래그 중 스크롤 비활성화**: 스크롤 이벤트 자체를 막음.
    - 장점: 선택 변경 문제 원천 차단.
    - 단점: 많은 파일 선택 시 불편함, 기능 제한.
    - 기각 이유: 스크롤은 유용한 기능이므로 유지하고 동작만 개선.
  - **자동 스크롤**: 드래그 중 마우스를 가장자리에 대면 자동 스크롤.
    - 장점: 일반적인 패턴, 마우스만으로 모든 조작 가능.
    - 단점: 추가 구현 필요, 현재 이슈와는 별개.
    - 판단: 향후 개선 사항으로 분류, 현재는 누적 방식으로 충분.
- **변경 사항**:
  - 126줄 추가, 74줄 삭제 (순 +52줄).
  - `updateSelection` 함수 삭제로 코드 중복 감소.
  - 각 핸들러에서 선택 계산 로직이 명확하게 드러남.
- **수정 파일**:
  - `apps/frontend/src/features/browse/hooks/useBoxSelection.ts`
- **Issue**: #25 (https://github.com/lteawoo/Cohesion/issues/25)
- **Commit**: `1c07bed`
- **향후 개선 고려 사항**:
  - 자동 스크롤 기능 추가 (마우스를 가장자리에 대면 자동으로 스크롤).
  - 선택 박스 시각적 피드백 개선 (누적되고 있음을 명확히 표시).
- **테스트 계획**: Grid 뷰에서 드래그 + 스크롤로 많은 파일 선택 후 선택 상태 유지 확인.
### Grid 뷰 이미지 썸네일 표시 방식 결정 (2026-02-11)
- **문제**: Grid 뷰에서 이미지 파일이 일반 파일 아이콘으로 표시되어 이미지 파일 식별이 어려움.
- **목표**: 이미지 파일의 실제 내용을 미리보기로 표시하여 사용자 경험 개선.
- **고려한 방안**:
  1. **프론트엔드 직접 로드 방식** (채택)
     - 기존 `/api/browse/download` 엔드포인트 활용.
     - 브라우저 네이티브 `loading="lazy"` 사용.
     - 장점: 빠른 구현, 별도 API 불필요, 간단한 아키텍처.
     - 단점: 원본 파일 다운로드 (네트워크 사용량 증가 가능).
  2. **백엔드 썸네일 생성 API**
     - 썸네일 생성 라이브러리 필요 (imaging, disintegration/imaging 등).
     - 썸네일 크기 조정 및 캐싱 구현.
     - 장점: 네트워크 효율적, 최적화된 이미지 제공.
     - 단점: 구현 복잡도 높음, 외부 의존성 추가, 캐싱 관리 필요.
  3. **하이브리드 방식**
     - 일정 크기 이하: 프론트엔드 직접 로드.
     - 일정 크기 이상: 백엔드 썸네일 생성.
     - 장점: 균형잡힌 접근.
     - 단점: 복잡도 증가, 일관성 부족.
- **결정**: 방안 1 (프론트엔드 직접 로드 방식) 채택.
- **이유**:
  - 빠른 구현: 기존 API 활용, 추가 백엔드 작업 없음.
  - 충분한 성능: 로컬 네트워크에서 원본 로드도 빠름, lazy loading으로 최적화.
  - 단순한 아키텍처: 유지보수 쉬움, 외부 의존성 없음.
  - 향후 확장 가능: 필요 시 백엔드 썸네일 생성으로 전환 가능.
- **구현**:
  - `ImageThumbnail` 컴포넌트 생성:
    ```typescript
    <img
      src={`/api/browse/download?path=${encodeURIComponent(path)}`}
      loading="lazy"
      onLoad={() => setLoading(false)}
      onError={() => setError(true)}
    />
    ```
  - `fileTypeUtils` 유틸리티: 이미지 확장자 감지 (jpg, jpeg, png, gif, webp, svg, bmp, ico).
  - `FolderContentGrid`: 이미지 파일 감지 시 `ImageThumbnail` 렌더링.
- **수정 파일**:
  - `apps/frontend/src/features/browse/components/ImageThumbnail.tsx` (신규)
  - `apps/frontend/src/features/browse/utils/fileTypeUtils.ts` (신규)
  - `apps/frontend/src/features/browse/components/FolderContent/FolderContentGrid.tsx`
- **Commit**: `6fade96`
- **향후 개선 고려 사항**:
  - 네트워크 사용량이 문제가 되면 백엔드 썸네일 생성 API 추가.
  - 더 많은 이미지 포맷 지원 (tiff, heic 등).
  - 비디오 파일 썸네일 지원.

### 이동/복사 모달 Space 트리 구조 결정 (2026-02-11)
- **문제**: 이동/복사 모달의 FolderTree가 잘못된 방식으로 동작.
  - **단일 Space만 표시**: `selectedSpace`가 있을 때 해당 Space 내부만 표시, Space 간 이동 불가능.
  - **시스템 디렉토리 노출**: `selectedSpace`가 없을 때 `/Users`, `/Applications` 등 시스템 디렉토리 표시 (보안/UX 문제).
- **올바른 동작**: 모든 Space 목록 표시, Space 간 파일 이동/복사 가능.
- **원인 분석**:
  - `DestinationPickerModal`이 `FolderTree`에 props 전달:
    ```typescript
    <FolderTree
      rootPath={selectedSpace?.space_path}
      rootName={selectedSpace?.space_name}
      showBaseDirectories={!selectedSpace}
    />
    ```
  - `FolderTree` 로직 우선순위:
    1. `showBaseDirectories`: 시스템 디렉토리 표시 (Space 등록용).
    2. `rootPath`, `rootName`: 단일 Space 표시.
    3. (props 없음): 모든 Space 목록 표시 (원하는 동작!).
- **고려한 방안**:
  1. **새로운 prop 추가** (`spacePickerMode`)
     - `FolderTree`에 `spacePickerMode` prop 추가하여 명시적으로 모드 구분.
     - 장점: 명확한 의도 표현.
     - 단점: prop 증가, 로직 복잡도 증가, 기존 동작 변경 위험.
  2. **Props 제거** (채택)
     - `DestinationPickerModal`에서 FolderTree props를 모두 제거.
     - `FolderTree`가 자동으로 모든 Space 표시 (3순위 로직).
     - 장점: 가장 간단, 명확, 기존 로직 활용.
     - 단점: 없음.
  3. **별도 컴포넌트 생성** (`SpacePicker`)
     - Space 선택 전용 컴포넌트 생성.
     - 장점: 명확한 분리.
     - 단점: 코드 중복, 유지보수 어려움, 과도한 추상화.
- **결정**: 방안 2 (Props 제거) 채택.
- **이유**:
  - 가장 간단한 해결책: 3줄 삭제로 문제 해결.
  - 기존 로직 활용: `FolderTree`가 이미 Space 목록 표시 기능 보유.
  - 메인 사이드바와 동일한 동작: 일관성 유지.
  - 안전한 변경: Space 등록 모달(`showBaseDirectories`)과 충돌 없음.
- **구현**:
  ```diff
  <FolderTree
    onSelect={handleSelect}
  - rootPath={selectedSpace?.space_path}
  - rootName={selectedSpace?.space_name}
  - showBaseDirectories={!selectedSpace}
  />
  ```
- **기술적 고려사항**:
  - **Space 경로 검증**: 백엔드 `isPathAllowed`로 Space 외부 이동 차단 (기존 구현).
  - **하위 폴더 순환 참조 방지**: 프론트엔드에서 사전 체크 (기존 구현).
  - **Space 목록 동기화**: Zustand store에서 자동으로 최신 목록 표시.
- **영향 분석**:
  - **Space 등록 모달**: `showBaseDirectories={true}` → 1순위 로직 (변경 없음).
  - **메인 사이드바**: props 없음 → 3순위 로직 (변경 없음).
  - **이동/복사 모달**: props 제거 → 3순위 로직 (개선됨).
- **수정 파일**:
  - `apps/frontend/src/features/browse/components/DestinationPickerModal.tsx` (3줄 삭제)
- **Commit**: `85ddd94`
- **테스트 계획**:
  - Space 간 파일 이동/복사 정상 작동 확인.
  - Space 등록 모달 정상 작동 확인 (회귀 테스트).
  - 메인 사이드바 정상 작동 확인 (회귀 테스트).
- **향후 개선 고려 사항**:
  - 현재 Space 강조 표시 (`defaultExpandedKeys`).
  - 최근 사용 폴더 기록 (localStorage).
  - Space 간 이동 시 확인 모달 추가.

### 이동/복사 모달 클릭 이벤트 버블링 처리 결정 (2026-02-13)
- **문제**: 이동/복사 모달에서 대상 폴더를 선택하면 파일 익스플로러의 기존 선택이 해제됨.
- **원인 분석**:
  - `FolderContent` 루트 컨테이너의 `onClick`(`handleContainerClick`)는 빈 영역 클릭 시 `clearSelection()` 수행.
  - 이동/복사 모달은 React Portal로 렌더링되지만 이벤트 버블링은 React 트리를 따라 상위 컴포넌트(`FolderContent`)로 전달됨.
  - 모달 내부의 Tree 노드 클릭이 컨테이너 빈 영역 클릭으로 오인되어 선택이 해제됨.
- **결정**: `handleContainerClick`에서 `.ant-modal` 내부 클릭은 선택 해제 로직에서 제외.
- **이유**:
  - 선택 해제 의도는 파일 목록 빈 영역 클릭에 한정되어야 함.
  - 모달 내부 조작은 원본 selection state를 유지해야 이동/복사 작업의 일관성이 보장됨.
  - 영향 범위가 작고 회귀 위험이 낮음.
- **구현**:
  - `const isModalContent = target.closest('.ant-modal');`
  - `if (isModalContent) return;`
- **수정 파일**:
  - `apps/frontend/src/features/browse/components/FolderContent.tsx`
- **검증**:
  - 린트/빌드 통과.
  - 브라우저 수동 테스트로 모달 폴더 선택 후에도 `N개 선택됨` 유지 확인.
  - 증빙 스크린샷: `.playwright-mcp/move-modal-selection-fixed.png`

### 이동/복사 모달에서 source selection 안정성 보강 결정 (2026-02-13)
- **추가 원인**:
  - 기존 구조는 이동/복사 모달이 `selectedItems`를 실시간 참조.
  - 전역 경로 상태(`selectedPath`, `selectedSpace`) 변화가 발생하면 `FolderContent`의 effect에서 `clearSelection()`이 실행되어 모달 작업 중 source가 사라질 수 있음.
- **근본 대응 결정**:
  1. 이동/복사 모달 오픈 시점의 source 목록을 스냅샷으로 고정.
  2. 모달 열림 중에는 네비게이션 변화가 있어도 자동 selection clear를 수행하지 않음.
- **구현**:
  - `useModalManager`의 `DestinationModalData`에 `sources: string[]` 추가.
  - `openModal('destination', { mode, sources })`로 현재 선택 목록 캡처.
  - `handleMoveConfirm`/`handleCopyConfirm`은 실시간 `selectedItems` 대신 `modals.destination.data.sources` 사용.
  - `selectedPath/selectedSpace` effect에서 `modals.destination.visible`일 때 `clearSelection()` skip.
- **수정 파일**:
  - `apps/frontend/src/features/browse/hooks/useModalManager.ts`
  - `apps/frontend/src/features/browse/components/FolderContent.tsx`

### 파일 작업 후 트리 반영을 위한 invalidate 구조 결정 (2026-02-13)
- **문제**: 복사/이동/삭제/이름변경/폴더생성 후 우측 목록은 갱신되지만, 좌측/모달 트리는 stale 상태가 남음.
- **원인**:
  - 파일 작업 훅(`useFileOperations`)은 `refreshContents()`로 현재 폴더 내용만 재조회.
  - `FolderTree`는 `treeData`, `loadedKeys`, `expandedKeys` 로컬 캐시를 유지하여 자동 무효화되지 않음.
- **결정**: 전역 `treeRefreshVersion` 기반 invalidate 패턴 도입.
- **구현**:
  - `browseStore`에 `treeRefreshVersion`, `invalidateTree()` 추가.
  - 파일 작업 성공 후(`rename/create-folder/delete/move/copy`) `invalidateTree()` 호출.
  - `FolderTree`는 `treeRefreshVersion` 변경을 감지해 초기 트리 데이터 재구성 및 로컬 캐시 초기화.
- **효과**:
  - 파일 작업 직후 트리 컴포넌트(사이드바/모달) stale 상태 해소.
  - 별도 수동 새로고침 없이 최신 구조 반영.

### 에이전트 실행 문서 위치 정리 결정 (2026-02-13)
- **결정**: 실행 환경 가이드를 `docs/AGENTS.md`에서 루트 `AGENTS.md`로 통합.
- **이유**:
  - 에이전트 진입 시점에 루트에서 즉시 참조 가능.
  - `CLAUDE.md`, `GEMINI.md`와의 참조 일관성 유지.
- **변경**:
  - `docs/AGENTS.md` 제거.
  - 루트 `AGENTS.md` 유지/갱신.
  - `master_rule_v2.md`의 검증 절차 문구 최신화.

### Settings/레이아웃 잔여 인라인 스타일 공통화 결정 (2026-02-16)
- **문제**:
  - `Settings` 섹션(`General/File/Server`)에 폭/간격 관련 인라인 스타일이 남아 있어 재사용성과 유지보수성이 떨어짐.
  - `MainLayout`/`MainSider`에도 소규모 인라인 구조 스타일이 남아 공통화 일관성이 낮음.
- **결정**:
  1. `settings.css`에 공통 유틸 클래스를 추가해 반복 스타일을 클래스 기반으로 치환.
  2. `global.css`에 레이아웃 보조 클래스(`layout-content-scroll-hidden`, `layout-sider-title`)를 추가해 상위 레이아웃과 일관화.
- **이유**:
  - 토큰 의존 동적 스타일(배경/보더 컬러)과 정적 구조 스타일(폭/여백/폰트)을 분리하면 변경 영향이 작고 회귀 위험이 낮음.
  - 이후 Settings 확장 시 인라인 복제를 줄이고 클래스 재사용이 가능함.
- **적용 내용**:
  - `GeneralSettings`: 언어 Select 폭 클래스화.
  - `FileSettings`: 정렬 Select 2개 `width: 100%` 클래스화.
  - `ServerSettings`: Alert padding, Divider margin, 포트 Input 폭, 보조 텍스트 크기 클래스화.
  - `Settings index`: 홈 아이콘 크기/메뉴 전체 높이·보더 클래스화.
  - `MainLayout/MainSider`: 콘텐츠 overflow/사이드 타이틀 스타일 클래스화.
- **검증**:
  - `pnpm -C apps/frontend lint` 통과.
  - `pnpm -C apps/frontend build` 통과.

### FTP 서버 1차 구현 방식 결정 (2026-02-16, #70)
- **문제**:
  - UI/설정 모델에 `ftpEnabled`, `ftpPort`가 존재하지만 실제 FTP 서버 구현이 없어 기능이 동작하지 않음.
  - 상태 API도 FTP를 하드코딩 `미구현`으로 반환해 실제 상태를 반영하지 못함.
- **검토안**:
  1. 외부 파일 드라이버(`goftp/file-driver`) 재사용:
     - 장점: 구현 빠름.
     - 단점: 경로 정규화/트래버셜 통제가 약해 Space 경계 보장에 불리.
  2. Space 가상 루트 커스텀 드라이버 구현 (채택):
     - `/{spaceName}/...` 구조로 Space 경계를 강제.
     - 루트에서는 Space 목록만 디렉토리로 노출.
     - 경로는 `filepath.Rel` 기반으로 Space 외부 접근 차단.
- **결정**:
  - `internal/ftp` 모듈 신설 및 커스텀 드라이버 채택.
  - `main` 재시작 lifecycle에 FTP start/stop 연동.
  - 상태 API FTP 항목을 실제 포트 연결 체크로 변경.
- **보안/운영 고려**:
  - 기본 포트는 비특권 포트 `2121`로 설정(개발/로컬 실행 안정성).
  - 기본 계정은 `cohesion/cohesion`, 환경변수(`COHESION_FTP_USER`, `COHESION_FTP_PASSWORD`)로 오버라이드 가능.
  - FTPS(TLS), SFTP, 다중 계정은 후속 이슈에서 확장.
- **변경 파일**:
  - `apps/backend/internal/ftp/driver.go` (Space 가상 루트 드라이버)
  - `apps/backend/internal/ftp/service.go` (FTP 서비스 lifecycle)
  - `apps/backend/internal/ftp/logger.go` (FTP 로그 어댑터)
  - `apps/backend/main.go` (재시작 루프 연동)
  - `apps/backend/internal/status/handler.go` (FTP 상태 실연동)
  - `apps/backend/config/config.dev.yaml`, `apps/backend/config/config.prod.yaml` (기본 포트/키 정리)
  - `apps/frontend/src/pages/Settings/sections/ServerSettings.tsx` (FTP 문구 정리)
- **검증**:
  - `go test ./...` (apps/backend) 통과.
  - `pnpm -C apps/frontend build` 통과.

### 계정/권한 모델 및 FTP 인증 전환 결정 (2026-02-16, #72)
- **요구사항**:
  - `owner` 없이 `admin` 단일 최고권한으로 관리.
  - 사용자별 FTP 계정(아이디/비밀번호/닉네임)과 Space 권한 제어 필요.
- **결정**:
  1. 역할은 `admin | user`만 유지 (`owner` 제거).
  2. Space 권한은 `read | write | manage` 3단계로 관리.
  3. FTP 인증은 고정 계정 방식에서 DB 계정 검증 방식으로 전환.
  4. FTP 접근은 `deny by default` 정책:
     - `admin`: 전체 Space 허용
     - `user`: `user_space_permissions`에 명시된 Space만 허용
     - 쓰기 연산은 `write` 이상 권한 필요
- **이유**:
  - 단일 최고권한(admin)으로 운영 모델 단순화.
  - Space 중심 도메인 구조와 자연스럽게 결합.
  - FTP를 사용자 권한 모델에 편입해 보안 일관성 확보.
- **적용 내용**:
  - 스키마 추가: `users`, `user_space_permissions`.
  - 백엔드 모듈 추가: `internal/account`(store/service/handler).
  - FTP 모듈 변경:
    - auth: `account.Service.Authenticate` 사용
    - driver: 로그인 사용자 기준 Space 목록/읽기/쓰기 권한 체크
  - 서버 부팅 시 기본 admin 보장:
    - `COHESION_ADMIN_USER`, `COHESION_ADMIN_PASSWORD`, `COHESION_ADMIN_NICKNAME`
    - 미지정 시 `admin/admin1234` 생성
- **API**:
  - `GET/POST /api/accounts`
  - `PATCH/DELETE /api/accounts/{id}`
  - `GET/PUT /api/accounts/{id}/permissions`
- **검증**:
  - `go test ./...` (apps/backend) 통과.
  - `pnpm -C apps/frontend build` 통과.

## 2026-02-18: 파일 익스플로러 외곽 여백 박스선택 시작 경계 확장 연결
- **상황**:
  - `useBoxSelection` 훅에 시작 경계 확장(`startAreaOutsetPx`)을 추가했지만 `FolderContent`에서 값을 주입하지 않아 외곽 여백 시작 드래그가 여전히 차단됨.
- **결정**:
  - `FolderContent`에서 `startAreaOutsetPx: 16`을 명시적으로 전달해 `FileExplorer` 패딩(16px) 영역까지 시작 판정을 확장.
- **이유**:
  - 레이아웃 패딩은 유지하면서 드래그 시작 인식 범위만 안전하게 넓히는 최소 변경.
- **적용 파일**:
  - `apps/frontend/src/features/browse/components/FolderContent.tsx`

## 2026-02-18: 박스선택 오버레이 렌더 레이어 상향
- **상황**:
  - 시작 영역은 외곽까지 확장됐지만, 선택 박스 DOM이 `overflow:auto` 컨테이너 내부에 있어 파일 익스플로러 바깥에서 시각적으로 잘림.
- **결정**:
  - 오버레이를 `FolderContent` 루트 레이어(상위)에서 렌더링.
  - 선택 좌표(콘텐츠 기준)는 유지하고, 렌더 시 `selectionContainer`의 위치/스크롤 오프셋을 더해 표시 좌표를 보정.
- **이유**:
  - 선택 교차 판정 로직은 그대로 유지하면서 시각적 클리핑만 분리 해결 가능한 최소 리스크 수정.
- **적용 파일**:
  - `apps/frontend/src/features/browse/components/FolderContent.tsx`
  - `apps/frontend/src/features/browse/components/FolderContent/BoxSelectionOverlay.tsx`

## 2026-02-18: PR 마무리용 프론트 타입 안정화 정리
- **상황**:
  - `pnpm -C apps/frontend build` 시 암시적 any/nullable 관련 타입 에러로 빌드 실패.
- **결정**:
  - 테이블 메뉴 클릭 핸들러에 명시 타입을 부여하고, 테이블 제네릭을 `FileNode`로 고정.
  - 컨텍스트 메뉴 빈영역 메뉴 구성 결과에 null/undefined 가드 추가.
- **이유**:
  - 기능 변경 없이 타입 안정성을 높여 PR 검증(빌드) 기준 충족.
- **적용 파일**:
  - `apps/frontend/src/features/browse/components/FolderContent/FolderContentTable.tsx`
  - `apps/frontend/src/features/browse/hooks/useContextMenu.ts`

## 2026-02-18: 테이블 선택 UX 및 선택색상 공통화
- **상황**:
  - PC 테이블에서 단일 선택 반응이 둔하게 느껴지고, 멀티선택(Shift/Ctrl) 체감이 불안정함.
  - 그리드/테이블 선택 하이라이트 색상값이 분산되어 미세 불일치가 발생.
- **결정**:
  - 테이블 row drag를 비활성화하고, 선택 로직을 앵커 기반으로 정리(Shift=범위 치환, Ctrl/Cmd+Shift=범위 추가).
  - 컨텍스트 메뉴 선택 인덱스 기준을 `sortedContent`로 통일.
  - 선택/드래그오버 색상을 CSS 변수(`--browse-selection-*`)로 공통화하고 그리드/테이블이 동일 값 참조.
- **이유**:
  - 입력 방식(클릭/터치)은 유지하면서 렌더/상태 갱신 부담과 인덱스 불일치에서 오는 UX 흔들림을 최소화.
  - 향후 톤 조정을 단일 지점에서 제어 가능.
- **적용 파일**:
  - `apps/frontend/src/features/browse/hooks/useFileSelection.ts`
  - `apps/frontend/src/features/browse/components/FolderContent.tsx`
  - `apps/frontend/src/features/browse/components/FolderContent/FolderContentTable.tsx`
  - `apps/frontend/src/features/browse/components/FolderContent/FolderContentGrid.tsx`
  - `apps/frontend/src/features/browse/hooks/useBoxSelection.ts`
  - `apps/frontend/src/assets/css/global.css`

## 2026-02-20: 모바일 파일 익스플로러 스크롤 입력 경로 보정
- **상황**:
  - 파일 익스플로러에서 모바일 화면 기준(table/grid 공통) 스크롤 입력이 불안정했고, 스와이프 중 롱프레스 선택 전환이 간헐적으로 겹칠 수 있는 구조였음.
  - 모바일 선택 바 캡처 이벤트에 `preventDefault`가 포함되어 있어 상단 영역 제스처를 불필요하게 차단할 여지가 있었음.
  - 모바일 브레이크포인트에서는 루트 휠 라우팅이 비활성화되어 좁은 화면의 휠 입력 경로가 일관되지 않았음.
- **결정**:
  - `selectionContainer`에 터치 캡처 핸들러를 추가해 pan 임계치(`8px`) 이동 시 롱프레스 타이머를 즉시 취소.
  - pan 종료 직후 짧은 탭 억제(`suppressTapUntil`)를 적용해 스크롤 후 오탭 선택을 방지.
  - 모바일 선택 바의 `onPointerDownCapture/onTouchStartCapture/onClickCapture`에서 `preventDefault`를 제거하고 비버튼 대상만 전파 차단.
  - `handleRootWheelCapture`를 모바일 브레이크포인트에서도 동작하도록 조정(모달 오픈 시만 차단).
- **이유**:
  - table/grid 공통 부모(`FolderContent`)에서 입력 경로를 일원화하면 뷰별 분기 없이 동일하게 문제를 해결할 수 있음.
  - 롱프레스 선택 UX는 유지하면서 스크롤 제스처와 충돌 가능성만 최소화할 수 있음.
- **적용 파일**:
  - `apps/frontend/src/features/browse/components/FolderContent.tsx`
- **검증**:
  - `pnpm -C apps/frontend lint` 통과.
  - `pnpm -C apps/frontend exec tsc --noEmit` 통과.
  - `pnpm -C apps/frontend build` 통과.
  - Chrome DevTools 모바일 에뮬레이션에서 table/grid 각각:
    - `touchstart + touchmove` 시 선택 바 미노출(롱프레스 취소 확인).
    - `touchstart` 유지(롱프레스) 시 선택 바 노출(기존 UX 유지 확인).

## 2026-02-20: 파일 익스플로러 휠 보정 제거(네이티브 스크롤 복귀)
- **상황**:
  - 파일 익스플로러 루트의 `onWheelCapture` 보정 경로가 디버깅 포인트를 늘리고, 모바일/좁은 뷰포트 조건과 결합해 동작 해석을 복잡하게 만듦.
- **결정**:
  - `FolderContent`의 `handleRootWheelCapture`와 `onWheelCapture` 연결을 제거하고 브라우저 기본 스크롤 경로만 사용.
- **이유**:
  - 스크롤 입력을 표준 동작으로 단순화해 회귀 원인을 줄이고 유지보수성을 높이기 위함.
  - 현재 구조에서 실제 스크롤 컨테이너(`selectionContainer`)가 명확해 네이티브 경로로 충분히 동작 가능.
- **적용 파일**:
  - `apps/frontend/src/features/browse/components/FolderContent.tsx`
- **검증**:
  - `pnpm -C apps/frontend lint` 통과.
  - `pnpm -C apps/frontend exec tsc --noEmit` 통과.
